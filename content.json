{"meta":{"title":"松松闲谈","subtitle":"","description":"记录一下学习旅程","author":"shensongpeng","url":"https://songsong.ink","root":"/"},"pages":[{"title":"我的分类","date":"2021-07-12T03:33:53.000Z","updated":"2021-07-13T01:33:29.897Z","comments":true,"path":"categories/index.html","permalink":"https://songsong.ink/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-12T03:35:00.000Z","updated":"2021-07-13T01:33:38.695Z","comments":true,"path":"tags/index.html","permalink":"https://songsong.ink/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"垃圾收集","slug":"垃圾收集","date":"2021-07-21T02:25:59.000Z","updated":"2021-07-21T04:13:57.593Z","comments":true,"path":"2021/07/21/垃圾收集/","link":"","permalink":"https://songsong.ink/2021/07/21/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/","excerpt":"","text":"对象已死判断引用计数法引用计数法实在对象中添加一个引用计数器，每当有一个地方引用他时，计数器就加一；当引用失效时，计数器减一；任何时刻计数器为0的对象就是不可能在被使用的。 引用计数法回占用一些额外的存储空间来进行计数，但是原理简单，判断效率搞。但是看似简单的算法有很多例外的情况需要考虑，譬如单纯的引用计数法无法解决对象之间循环引用的问题，这就需要大量额外处理才能保证正确地工作。 循环引用问题对象objA 和 objB都有字段instance，令 ，objB.instance = objA。此外两个对象没有其他引用，实际上两个对象已经不可能在被访问，但是他们互选引用着对方，导致他们的引用计数器不为0，引用计数算法无法对他们进行回收。 代码样例 123456789101112131415161718192021222324252627public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024*1024; /** * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过 */ private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; // 假设在这行发生GC，objA和objB是否能被回收？ System.gc(); &#125; public static void main(String[] args) &#123; testGC(); &#125;&#125; 可达性分析可达性分析（eachability Analysis）的基本思路时通过一系列GC ROOTs 的根对象作为其实节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain）如果这个对象到GC ROOTS没有任何引用链相连，或者说不可达，则证明对象不可能再使用的。 GC ROOTs的对象固定的GC ROOTS集合 虚拟机栈（栈帧中的本地变量表）中引用的对象，比如使用到的参数、局部变量、临时变量等 方法区中类静态属性引用的变量，比如java类的引用类型静态变量 方法区中常量引用的对象，比如字符串常量池（String table）的引用 本地方法栈中JNI（native方法）引用的对象 java虚拟机内部的引用，比如基本数据类型对应的Class对象，常驻异常对象（OutOfMEmoryError NullPointException）等，还有系统类加载器 同步锁持有的对象 java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存 非固定的GC ROOTS根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。（跨代引用问题） 引用分类引用计数算法和可达性分析都是通过引用来判断对象是否存活。一个对象只有“引用”和“引用未”这两种状态在有些情况下不能完全适用。比如缓存这种对象，当内存空间还足够时，能够保留在内存中，如果内存空间进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象。 JDK1.2后引用的概念进行了扩充引用的分类有 强引用 Object obj=new Object() 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 软引用 描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。 弱引用 描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 虚引用 也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。","categories":[{"name":"jvm","slug":"jvm","permalink":"https://songsong.ink/categories/jvm/"}],"tags":[{"name":"垃圾收集算法","slug":"垃圾收集算法","permalink":"https://songsong.ink/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"},{"name":"对象死亡判断","slug":"对象死亡判断","permalink":"https://songsong.ink/tags/%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E6%96%AD/"}]},{"title":"mysql缓冲池","slug":"mysql缓冲池","date":"2021-07-20T10:05:19.000Z","updated":"2021-07-21T05:31:38.298Z","comments":true,"path":"2021/07/20/mysql缓冲池/","link":"","permalink":"https://songsong.ink/2021/07/20/mysql%E7%BC%93%E5%86%B2%E6%B1%A0/","excerpt":"","text":"","categories":[{"name":"mysql","slug":"mysql","permalink":"https://songsong.ink/categories/mysql/"}],"tags":[{"name":"缓冲池","slug":"缓冲池","permalink":"https://songsong.ink/tags/%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"name":"mysql","slug":"mysql","permalink":"https://songsong.ink/tags/mysql/"}]},{"title":"7.20工作记录","slug":"7-20工作记录","date":"2021-07-20T08:13:10.000Z","updated":"2021-07-20T08:14:12.406Z","comments":true,"path":"2021/07/20/7-20工作记录/","link":"","permalink":"https://songsong.ink/2021/07/20/7-20%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/","excerpt":"","text":"创意目前先将物料存放到对象里，之后在确定是否落到数据库","categories":[],"tags":[]},{"title":"JVM基础故障处理工具","slug":"JVM基础故障处理工具","date":"2021-07-19T05:51:53.000Z","updated":"2021-07-20T05:59:45.177Z","comments":true,"path":"2021/07/19/JVM基础故障处理工具/","link":"","permalink":"https://songsong.ink/2021/07/19/JVM%E5%9F%BA%E7%A1%80%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/","excerpt":"","text":"基础故障处理工具1.jdk小工具命名方式JDK的很多小工具的名字都参考了UNIX命令的命名方式。 2.jps（JVM Process Status Tool）jps是虚拟机进程状况工具。jps名字和UNIX的ps命令类似，它的功能也和ps命令类似： 可以列出正在运行的虚拟机进程， 显示虚拟机执行主类（Main Class，main()函数所在的类）名称 以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。 2.1jps命令格式1jps [options] [hostid] 参数 描述 -q 只输出LVMID，省略主类的名称 -m 输出虚拟机进程启动时传递给主类main（）函数的参数 -l 输出主类的全名，如果进程执行的是jar包，则输出JAR路径 -v 输出虚拟机进程启动时的JVM参数 jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，参数hostid为RMI注册表中注册的主机名。 2.2jps执行样例1234567jps -l4672 sun.tools.jps.Jps7364 org.jetbrains.jps.cmdline.Launcher24440 C:/Program28808 org.jetbrains.jps.cmdline.Launcher5128 3.jstat (JVM Statistics Monitoring Tool )jstat是jdk自带的虚拟机统计信息监视工具。用于监视虚拟机各种运行状态信息的工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾手机、即时编译等运行时数据，在只提供了控制台的服务器上，它将是在软件运行期间定位虚拟机性能问题的常用工具。 3.1命令格式1jstat [option vmid interval[s|ms] [count]] ] 对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的；如果是远程虚拟机进程，那VMID的格式应当是： 1[protocol:][//]lvmid[@hostname[:port]/servername] 参数interval和count代表查询间隔和次数，如果省略这2个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat -gc 2764 250 20选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。详细请参考表4-2中的描述。 选项 作用 -class 监视类加载、卸载数量、总空间以及类加载所消耗的时间 -gc 监视java堆情况，包括Eden区、survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息 -gccapacity 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 -gcutil 监视内容与-gc基本相同，但输出主要关注以使用空间占总空间的百分比 -gccause 监视内容与-gcutil功能一样，但是会额外输出导致上一次垃圾收集产生的原因 -gcnew 监视新生代垃圾收集状况 -gcnewcapacity 监视内容与-gc基本相同，但输出主要关注使用到的最大、最小空间 -gcold 监视老年代垃圾收集状况 -gcoldcapacity 监视内容与-gcold基本相同，但输出主要关注使用到的最大、最小空间 -gcmetacapacity 输出元空间使用到的最大、最小空间 -compiler 输出即时编译器编译过的方法，耗时等信息 -printcompilation 输出已经被即时编译的方法 缩写 描述 S0C 第一个幸存区的大小 S1C 第二个幸存区的大小 S0U 第一个幸存区的使用大小 S1U 第二个幸存区的使用大小 EC 伊甸园区的大小 EU 伊甸园区的使用大小 OC 老年代大小 OU 老年代使用大小 MC 方法区大小(元空间) MU 方法区使用大小 CCSC 压缩类空间大小 CCSU CCSU:压缩类空间使用大小 YGC 年轻代垃圾回收次数 YGCT 年轻代垃圾回收消耗时间，单位s FGC 老年代垃圾回收次数 FGCT 老年代垃圾回收消耗时间，单位s GCT 垃圾回收消耗总时间，单位s 3.jinfo Java配置信息工具4.jmap java内存映像工具5.jhat 虚拟机堆转储快照分析工具6.jstack Java堆栈跟踪工具基础工具总结","categories":[{"name":"jvm","slug":"jvm","permalink":"https://songsong.ink/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://songsong.ink/tags/jvm/"},{"name":"基础故障","slug":"基础故障","permalink":"https://songsong.ink/tags/%E5%9F%BA%E7%A1%80%E6%95%85%E9%9A%9C/"}]},{"title":"5815. 扣分后的最大得分","slug":"5815-扣分后的最大得分","date":"2021-07-18T06:21:40.499Z","updated":"2021-07-18T10:40:49.802Z","comments":true,"path":"2021/07/18/5815-扣分后的最大得分/","link":"","permalink":"https://songsong.ink/2021/07/18/5815-%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","excerpt":"","text":"扣分后的最大得分题目给你一个 m x n 的整数矩阵 points （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。 你的得分方式为：每一行 中选取一个格子，选中坐标为 (r, c) 的格子会给你的总得分 增加 points[r][c] 。 然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 r 和 r + 1 （其中 0 &lt;= r &lt; m - 1），选中坐标为 (r, c1) 和 (r + 1, c2) 的格子，你的总得分 减少 abs(c1 - c2) 。 请你返回你能得到的 最大 得分。 abs(x) 定义为： 如果 x &gt;= 0 ，那么值为 x 。 如果 x &lt; 0 ，那么值为 -x 。 思路 回溯 动态规划 动态规划优化 选择问题一般都可以用回溯的思路进行解决，但是回溯的时间复杂度很大。 1234567891011121314151617181920class Solution &#123; int res = 0; public long maxPoints(int[][] points) &#123; dfs(points,0,0,0); return res; &#125; public void dfs(int[][] points,int row, int col, int score)&#123; if (row &gt;= points.length) &#123; res = Math.max(res,score); return; &#125; for (int i = 0; i &lt; points[row].length; i++) &#123; int newScore = score + points[row][i]; if (row &gt; 0)&#123; newScore -= Math.abs(col - i); &#125; dfs(points,row+1,i,newScore); &#125; &#125;&#125; 动态规划解法dp[i][j] 代表i行j列的最大得分 状态转移方程：dp[i][j] = max{ dp[i-1][k] + points[i][j] + abs(j-k) ,k = 0-n n为points列长度}时间复杂度？ 123456789101112131415161718192021222324252627282930class Solution &#123; public long maxPoints(int[][] points) &#123; if (points.length == 0) &#123; return 0; &#125; long result = 0; int m = points.length; int n = points[0].length; long[][] dp = new long[m][n]; for (int i = 0; i &lt; n; i++) &#123; dp[0][i] = points[0][i]; result = Math.max(result,dp[0][i]); &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; long score = points[i][j] + dp[i-1][k] - Math.abs(j-k); dp[i][j] = Math.max(score,dp[i][j]); &#125; result = Math.max(result,dp[i][j]); &#125; &#125; return result; &#125; &#125; 动态规划优化解法 12","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://songsong.ink/categories/leetcode/"}],"tags":[{"name":"周赛","slug":"周赛","permalink":"https://songsong.ink/tags/%E5%91%A8%E8%B5%9B/"},{"name":"面试","slug":"面试","permalink":"https://songsong.ink/tags/%E9%9D%A2%E8%AF%95/"},{"name":"中等","slug":"中等","permalink":"https://songsong.ink/tags/%E4%B8%AD%E7%AD%89/"}]},{"title":"面试题 10.02. 变位词组","slug":"新的文章","date":"2021-07-17T14:48:34.000Z","updated":"2021-07-18T02:31:51.774Z","comments":true,"path":"2021/07/17/新的文章/","link":"","permalink":"https://songsong.ink/2021/07/17/%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/","excerpt":"","text":"面试题 10.02. 变位词组题目描述编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 题解一问题分解 如何识别字符串是同一个变位词？ 同一个变位词如何快速加入到对应的数组中？ 思路：对于第一个问题： 对将变位词进行计数排序，返回排序好的字符串，将返回的字符串作为哈希表的key， 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.HashMap;import java.util;class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList(); HashMap&lt;String ,List&lt;String&gt;&gt; map = new HashMap(); for ( String str: strs) &#123; String key = count(str); List&lt;String&gt; list; if (!map.containsKey(key)) &#123; list = new ArrayList&lt;String&gt;(); result.add(list); map.put(key,list); &#125;else &#123; list = map.get(key); &#125; list.add(str); &#125; return result; &#125; public String count(String str) &#123; int[] bit = new int[26]; for (int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); bit[c -&#x27;a&#x27;] ++; &#125; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; 26; i++) &#123; char c = (char)(&#x27;a&#x27; + i); for (int j = 0; j &lt; bit[i]; j++) &#123; stringBuilder.append(c); &#125; &#125; return stringBuilder.toString(); &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://songsong.ink/categories/leetcode/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://songsong.ink/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"leetcode","slug":"leetcode","permalink":"https://songsong.ink/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"https://songsong.ink/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}]},{"title":"mysql索引","slug":"mysql索引","date":"2021-07-15T03:38:47.000Z","updated":"2021-07-15T03:38:47.074Z","comments":true,"path":"2021/07/15/mysql索引/","link":"","permalink":"https://songsong.ink/2021/07/15/mysql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"mysql索引索引是什么索引是帮助Mysql高效获取数据的排好序的数据结构。 索引可以用的数据结构有： 二叉树 红黑树 Hash表 B-Tree BTree 叶子节点具有相同的深度，叶节点的指针为空 所有索引元素不重复 节点中的数据索引从左往右递增排列 B+树（B树变种） 非叶子节点不存储data，只存储索引（索引会冗余），因此每页可以存储更多索引 叶子节点包含所有索引字段 叶子节点用指针连接，提高区间访问能力 聚集索引索引文件和数据文件在一起的是聚集索引。 非聚集索引索引文件和数据文件分离的是非聚集索引 InnoDB索引实现InnoDb索引是聚集索引。表数据本身就是按照B+树结构存储的一个索引结构文件。因此InnDB存储的表必须存在主键。辅助索引使用的非聚集索引。存储的是主键值。聚集索引的叶子节点包含了完整的数据记录。 为何InonoDB非主键索引结构叶子节点存储的是主键值非主键索引叶子节点存储主键而不是存储数据是从两方面考虑。一是如果存储数据数据的更新删除添加操作会存在数据不一致问题。维护数据一致性会很复杂。二是会浪费大量空间。 为什么InnoDb表必须有主键且推荐使用整型的自增主键表数据本身就是按照B+树结构存储的，因此必须有主键， 联合索引联合索引的存储结构也是采用b+树，索引值是按照构建索引时键的顺序存储。叶子节点存储的是主键值。 最左前缀原理如果要使用联合索引必须要遵循最左前缀原理使用。比如key（a,b,c）直接使用c是几乎不会走索引的。也就是说要使用联合索引的字段进行查询。在联合索引中这个字段的左侧字段也必须使用。不然不会走索引（覆盖索引例外）。 覆盖索引","categories":[{"name":"数据库","slug":"数据库","permalink":"https://songsong.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://songsong.ink/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"索引","slug":"索引","permalink":"https://songsong.ink/tags/%E7%B4%A2%E5%BC%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://songsong.ink/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"B+数","slug":"B-数","permalink":"https://songsong.ink/tags/B-%E6%95%B0/"},{"name":"Hash","slug":"Hash","permalink":"https://songsong.ink/tags/Hash/"}]},{"title":"三大范式","slug":"三大范式","date":"2021-07-15T03:33:24.000Z","updated":"2021-07-15T03:33:24.833Z","comments":true,"path":"2021/07/15/三大范式/","link":"","permalink":"https://songsong.ink/2021/07/15/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/","excerpt":"","text":"三大范式第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://songsong.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://songsong.ink/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"范式","slug":"范式","permalink":"https://songsong.ink/tags/%E8%8C%83%E5%BC%8F/"}]},{"title":"原型模式","slug":"原型模式","date":"2021-07-14T12:18:04.000Z","updated":"2021-07-14T12:18:04.123Z","comments":true,"path":"2021/07/14/原型模式/","link":"","permalink":"https://songsong.ink/2021/07/14/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式(Prototype)知识点 Cloneable接口/Object#clone方法 详解 浅拷贝/深拷贝 序列化机制实现深拷贝 模式定义:指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 应用场景：当代码不应该依赖于需要复制的对象的具体类时，请使用Prototype模式。 优点： 可以不耦合具体类的情况下克隆对象 避免重复的初始化代码 更方便的构建复杂对象 Spring源码中的应用 org.springframework.beans.factory.support.bstractBeanDefinition java.util.Arrays","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"原型模式","slug":"原型模式","permalink":"https://songsong.ink/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Prototype","slug":"Prototype","permalink":"https://songsong.ink/tags/Prototype/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://songsong.ink/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://songsong.ink/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}]},{"title":"观察者模式","slug":"观察者模式","date":"2021-07-14T12:07:30.000Z","updated":"2021-07-14T12:07:30.405Z","comments":true,"path":"2021/07/14/观察者模式/","link":"","permalink":"https://songsong.ink/2021/07/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式(Observer)模式定义定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题 对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新。 应用场景当更改一个对象的状态可能需要更改其他对象，并且实际的对象集事先 未知或动态更改时，请使用观察者模式。 优点 符合开闭原则 可以在运行时建立对象之间的关系 jdk&amp;源码中的应用 JDK: java.util.Observable Spring: org.springframework.context.ApplicationListener","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://songsong.ink/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"Observer","slug":"Observer","permalink":"https://songsong.ink/tags/Observer/"}]},{"title":"模板方法模式","slug":"模板方法模式","date":"2021-07-14T11:51:04.000Z","updated":"2021-07-14T11:59:24.943Z","comments":true,"path":"2021/07/14/模板方法模式/","link":"","permalink":"https://songsong.ink/2021/07/14/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板方法(Template Method)模式定义定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 样例代码1234567891011121314151617181920212223242526public class TemplateMethodTest &#123; public static void main(String[] args) &#123; AbstractClass abstractClass = new SubClass(); abstractClass.operation(); &#125;&#125;abstract class AbstractClass&#123; public void operation() &#123; // 定义一个操作的算法骨架 System.out.println(&quot; step 1&quot;); System.out.println(&quot; step 2&quot;); System.out.println(&quot; step 3&quot;); //步骤延迟 templateMethod(); &#125; protected abstract void templateMethod();&#125;class SubClass extends AbstractClass &#123; @Override protected void templateMethod() &#123; System.out.println(&quot;subclass step&quot;); &#125;&#125; 应用场景 当你想让客户端只扩展算法的特定步骤，而不是整个算法或其结构 时，请使用Template Method模式。 当你有几个类包含几乎相同的算法，但有一些细微的差异时，请使用 此模式。 优点： 你可以让客户端只覆盖大型算法的某些部分，从而减少算法其他部分发生的更改对它们的影响。 你可以将重复的代码拖放到超类中。 实际应用 javax.servlet.http.HttpServlet org.springframework.web.servlet.mvc.AbstractController","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"模板方法","slug":"模板方法","permalink":"https://songsong.ink/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"}]},{"title":"单例模式","slug":"单例模式","date":"2021-07-14T10:48:33.000Z","updated":"2021-07-14T11:44:53.647Z","comments":true,"path":"2021/07/14/单例模式/","link":"","permalink":"https://songsong.ink/2021/07/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式（Singleton）知识点 模式定义/应用场景/类图分析 字节码知识/字节码指令重排序 类加载机制 JVM序列化机制 单例模式在Spring框架 &amp; JDK源码中的应用 模式定义保证一个类只有一个实例，并且提供一个全局的访问点 使用场景重量级对象。不需要单个实例，如线程池，数据库连接池 实现方式1.懒汉模式懒汉模式：延迟加载， 只有在真正使用的时候，才开始实例化。 存在问题： 线程安全问题 double check 加锁优化 编译器(JIT),CPU 有可能对指令进行重排序，导致使用到尚未初始化 的实例，可以通过添加volatile 关键字进行修饰， 对于volatile 修饰的字段，可以防止指令重排。（具体原理后续文章展开） 1234567891011121314151617181920212223242526class LazySingleton&#123; private volatile static LazySingleton instance; private LazySingleton()&#123; &#125; public static LazySingleton getInstance() &#123; if (instance==null)&#123; synchronized (LazySingleton.class)&#123; if (instance==null)&#123; instance=new LazySingleton(); // 字节码层 // JIT ， CPU 有可能对如下指令进行重排序 // 1 .分配空间 // 2 .初始化 // 3 .引用赋值 // 如重排序后的结果为如下 // 1 .分配空间 // 3 .引用赋值 如果在当前指令执行完，有其他线程来获取实例，将拿到尚未初始化好的实例 // 2 .初始化 &#125; &#125; &#125; return instance; &#125;&#125; 2.饿汉模式：类加载的初始化阶段就完成了实例的初始化。本质上就是借助于jvm 类加载机制，保证实例的唯一性（初始化过程只会执行一次）及线程安全（JVM以同步的形式来完成类加载的整个过程）。 类加载过程： 加载二进制数据到内存中， 生成对应的Class数据结构， 连接： a. 验证， b.准备（给类的静态成员变量赋默认值），c.解析 初始化： 给类的静态变量赋初值 只有在真正使用对应的类时，才会触发初始化 如（ 当前类是启动类即 main函数所在类，直接进行new 操作，访问静态属性、访问静态方法，用反射访问类，初始化一个类的子类等.） 123456789// 饿汉模式 class HungrySingleton&#123; private static HungrySingleton instance=new HungrySingleton(); private HungrySingleton()&#123; &#125; public static HungrySingleton getInstance() &#123; return instance; &#125;&#125; 3.静态内部类 本质上是利用类的加载机制来保证线程安全 只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一 种形式。123456789class InnerClassSingleton&#123; private static class InnerClassHolder&#123; private static InnerClassSingleton instance= new InnerClassSingleton(); &#125; private InnerClassSingleton()&#123; &#125; public static InnerClassSingleton getInstance()&#123; return InnerClassHolder.instance; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://songsong.ink/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"懒加载","slug":"懒加载","permalink":"https://songsong.ink/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-09T04:39:55.408Z","updated":"2021-07-12T02:55:38.647Z","comments":true,"path":"2021/07/09/hello-world/","link":"","permalink":"https://songsong.ink/2021/07/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1$ hexo","categories":[],"tags":[]}],"categories":[{"name":"jvm","slug":"jvm","permalink":"https://songsong.ink/categories/jvm/"},{"name":"mysql","slug":"mysql","permalink":"https://songsong.ink/categories/mysql/"},{"name":"leetcode","slug":"leetcode","permalink":"https://songsong.ink/categories/leetcode/"},{"name":"数据库","slug":"数据库","permalink":"https://songsong.ink/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"垃圾收集算法","slug":"垃圾收集算法","permalink":"https://songsong.ink/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"},{"name":"对象死亡判断","slug":"对象死亡判断","permalink":"https://songsong.ink/tags/%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E5%88%A4%E6%96%AD/"},{"name":"缓冲池","slug":"缓冲池","permalink":"https://songsong.ink/tags/%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"name":"mysql","slug":"mysql","permalink":"https://songsong.ink/tags/mysql/"},{"name":"jvm","slug":"jvm","permalink":"https://songsong.ink/tags/jvm/"},{"name":"基础故障","slug":"基础故障","permalink":"https://songsong.ink/tags/%E5%9F%BA%E7%A1%80%E6%95%85%E9%9A%9C/"},{"name":"周赛","slug":"周赛","permalink":"https://songsong.ink/tags/%E5%91%A8%E8%B5%9B/"},{"name":"面试","slug":"面试","permalink":"https://songsong.ink/tags/%E9%9D%A2%E8%AF%95/"},{"name":"中等","slug":"中等","permalink":"https://songsong.ink/tags/%E4%B8%AD%E7%AD%89/"},{"name":"面试题","slug":"面试题","permalink":"https://songsong.ink/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"leetcode","slug":"leetcode","permalink":"https://songsong.ink/tags/leetcode/"},{"name":"每日一题","slug":"每日一题","permalink":"https://songsong.ink/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"数据库","slug":"数据库","permalink":"https://songsong.ink/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"索引","slug":"索引","permalink":"https://songsong.ink/tags/%E7%B4%A2%E5%BC%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://songsong.ink/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"B+数","slug":"B-数","permalink":"https://songsong.ink/tags/B-%E6%95%B0/"},{"name":"Hash","slug":"Hash","permalink":"https://songsong.ink/tags/Hash/"},{"name":"范式","slug":"范式","permalink":"https://songsong.ink/tags/%E8%8C%83%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://songsong.ink/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"原型模式","slug":"原型模式","permalink":"https://songsong.ink/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Prototype","slug":"Prototype","permalink":"https://songsong.ink/tags/Prototype/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://songsong.ink/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://songsong.ink/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://songsong.ink/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"Observer","slug":"Observer","permalink":"https://songsong.ink/tags/Observer/"},{"name":"模板方法","slug":"模板方法","permalink":"https://songsong.ink/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"name":"单例模式","slug":"单例模式","permalink":"https://songsong.ink/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"懒加载","slug":"懒加载","permalink":"https://songsong.ink/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"}]}