{"meta":{"title":"松松闲谈","subtitle":"","description":"记录一下学习旅程","author":"shensongpeng","url":"https://shensongpeng.github.io","root":"/"},"pages":[{"title":"我的分类","date":"2021-07-12T03:33:53.000Z","updated":"2021-07-13T01:33:29.897Z","comments":true,"path":"categories/index.html","permalink":"https://shensongpeng.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-07-12T03:35:00.000Z","updated":"2021-07-13T01:33:38.695Z","comments":true,"path":"tags/index.html","permalink":"https://shensongpeng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql索引","slug":"mysql索引","date":"2021-07-15T03:38:47.000Z","updated":"2021-07-15T03:38:47.074Z","comments":true,"path":"2021/07/15/mysql索引/","link":"","permalink":"https://shensongpeng.github.io/2021/07/15/mysql%E7%B4%A2%E5%BC%95/","excerpt":"","text":"mysql索引索引是什么索引是帮助Mysql高效获取数据的排好序的数据结构。 索引可以用的数据结构有： 二叉树 红黑树 Hash表 B-Tree BTree 叶子节点具有相同的深度，叶节点的指针为空 所有索引元素不重复 节点中的数据索引从左往右递增排列 B+树（B树变种） 非叶子节点不存储data，只存储索引（索引会冗余），因此每页可以存储更多索引 叶子节点包含所有索引字段 叶子节点用指针连接，提高区间访问能力 聚集索引索引文件和数据文件在一起的是聚集索引。 非聚集索引索引文件和数据文件分离的是非聚集索引 InnoDB索引实现InnoDb索引是聚集索引。表数据本身就是按照B+树结构存储的一个索引结构文件。因此InnDB存储的表必须存在主键。辅助索引使用的非聚集索引。存储的是主键值。聚集索引的叶子节点包含了完整的数据记录。 为何InonoDB非主键索引结构叶子节点存储的是主键值非主键索引叶子节点存储主键而不是存储数据是从两方面考虑。一是如果存储数据数据的更新删除添加操作会存在数据不一致问题。维护数据一致性会很复杂。二是会浪费大量空间。 为什么InnoDb表必须有主键且推荐使用整型的自增主键表数据本身就是按照B+树结构存储的，因此必须有主键， 联合索引联合索引的存储结构也是采用b+树，索引值是按照构建索引时键的顺序存储。叶子节点存储的是主键值。 最左前缀原理如果要使用联合索引必须要遵循最左前缀原理使用。比如key（a,b,c）直接使用c是几乎不会走索引的。也就是说要使用联合索引的字段进行查询。在联合索引中这个字段的左侧字段也必须使用。不然不会走索引（覆盖索引例外）。 覆盖索引","categories":[{"name":"数据库","slug":"数据库","permalink":"https://shensongpeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://shensongpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"索引","slug":"索引","permalink":"https://shensongpeng.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shensongpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"B+数","slug":"B-数","permalink":"https://shensongpeng.github.io/tags/B-%E6%95%B0/"},{"name":"Hash","slug":"Hash","permalink":"https://shensongpeng.github.io/tags/Hash/"}]},{"title":"三大范式","slug":"三大范式","date":"2021-07-15T03:33:24.000Z","updated":"2021-07-15T03:33:24.833Z","comments":true,"path":"2021/07/15/三大范式/","link":"","permalink":"https://shensongpeng.github.io/2021/07/15/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/","excerpt":"","text":"三大范式第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖） 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://shensongpeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://shensongpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"范式","slug":"范式","permalink":"https://shensongpeng.github.io/tags/%E8%8C%83%E5%BC%8F/"}]},{"title":"原型模式","slug":"原型模式","date":"2021-07-14T12:18:04.000Z","updated":"2021-07-14T12:18:04.123Z","comments":true,"path":"2021/07/14/原型模式/","link":"","permalink":"https://shensongpeng.github.io/2021/07/14/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"原型模式(Prototype)知识点 Cloneable接口/Object#clone方法 详解 浅拷贝/深拷贝 序列化机制实现深拷贝 模式定义:指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 应用场景：当代码不应该依赖于需要复制的对象的具体类时，请使用Prototype模式。 优点： 可以不耦合具体类的情况下克隆对象 避免重复的初始化代码 更方便的构建复杂对象 Spring源码中的应用 org.springframework.beans.factory.support.bstractBeanDefinition java.util.Arrays","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"原型模式","slug":"原型模式","permalink":"https://shensongpeng.github.io/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Prototype","slug":"Prototype","permalink":"https://shensongpeng.github.io/tags/Prototype/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://shensongpeng.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://shensongpeng.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}]},{"title":"观察者模式","slug":"观察者模式","date":"2021-07-14T12:07:30.000Z","updated":"2021-07-14T12:07:30.405Z","comments":true,"path":"2021/07/14/观察者模式/","link":"","permalink":"https://shensongpeng.github.io/2021/07/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"观察者模式(Observer)模式定义定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题 对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新。 应用场景当更改一个对象的状态可能需要更改其他对象，并且实际的对象集事先 未知或动态更改时，请使用观察者模式。 优点 符合开闭原则 可以在运行时建立对象之间的关系 jdk&amp;源码中的应用 JDK: java.util.Observable Spring: org.springframework.context.ApplicationListener","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://shensongpeng.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"Observer","slug":"Observer","permalink":"https://shensongpeng.github.io/tags/Observer/"}]},{"title":"模板方法模式","slug":"模板方法模式","date":"2021-07-14T11:51:04.000Z","updated":"2021-07-14T11:59:24.943Z","comments":true,"path":"2021/07/14/模板方法模式/","link":"","permalink":"https://shensongpeng.github.io/2021/07/14/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"模板方法(Template Method)模式定义定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤 样例代码1234567891011121314151617181920212223242526public class TemplateMethodTest &#123; public static void main(String[] args) &#123; AbstractClass abstractClass = new SubClass(); abstractClass.operation(); &#125;&#125;abstract class AbstractClass&#123; public void operation() &#123; // 定义一个操作的算法骨架 System.out.println(&quot; step 1&quot;); System.out.println(&quot; step 2&quot;); System.out.println(&quot; step 3&quot;); //步骤延迟 templateMethod(); &#125; protected abstract void templateMethod();&#125;class SubClass extends AbstractClass &#123; @Override protected void templateMethod() &#123; System.out.println(&quot;subclass step&quot;); &#125;&#125; 应用场景 当你想让客户端只扩展算法的特定步骤，而不是整个算法或其结构 时，请使用Template Method模式。 当你有几个类包含几乎相同的算法，但有一些细微的差异时，请使用 此模式。 优点： 你可以让客户端只覆盖大型算法的某些部分，从而减少算法其他部分发生的更改对它们的影响。 你可以将重复的代码拖放到超类中。 实际应用 javax.servlet.http.HttpServlet org.springframework.web.servlet.mvc.AbstractController","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"模板方法","slug":"模板方法","permalink":"https://shensongpeng.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"}]},{"title":"单例模式","slug":"单例模式","date":"2021-07-14T10:48:33.000Z","updated":"2021-07-14T11:44:53.647Z","comments":true,"path":"2021/07/14/单例模式/","link":"","permalink":"https://shensongpeng.github.io/2021/07/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单例设计模式（Singleton）知识点 模式定义/应用场景/类图分析 字节码知识/字节码指令重排序 类加载机制 JVM序列化机制 单例模式在Spring框架 &amp; JDK源码中的应用 模式定义保证一个类只有一个实例，并且提供一个全局的访问点 使用场景重量级对象。不需要单个实例，如线程池，数据库连接池 实现方式1.懒汉模式懒汉模式：延迟加载， 只有在真正使用的时候，才开始实例化。 存在问题： 线程安全问题 double check 加锁优化 编译器(JIT),CPU 有可能对指令进行重排序，导致使用到尚未初始化 的实例，可以通过添加volatile 关键字进行修饰， 对于volatile 修饰的字段，可以防止指令重排。（具体原理后续文章展开） 1234567891011121314151617181920212223242526class LazySingleton&#123; private volatile static LazySingleton instance; private LazySingleton()&#123; &#125; public static LazySingleton getInstance() &#123; if (instance==null)&#123; synchronized (LazySingleton.class)&#123; if (instance==null)&#123; instance=new LazySingleton(); // 字节码层 // JIT ， CPU 有可能对如下指令进行重排序 // 1 .分配空间 // 2 .初始化 // 3 .引用赋值 // 如重排序后的结果为如下 // 1 .分配空间 // 3 .引用赋值 如果在当前指令执行完，有其他线程来获取实例，将拿到尚未初始化好的实例 // 2 .初始化 &#125; &#125; &#125; return instance; &#125;&#125; 2.饿汉模式：类加载的初始化阶段就完成了实例的初始化。本质上就是借助于jvm 类加载机制，保证实例的唯一性（初始化过程只会执行一次）及线程安全（JVM以同步的形式来完成类加载的整个过程）。 类加载过程： 加载二进制数据到内存中， 生成对应的Class数据结构， 连接： a. 验证， b.准备（给类的静态成员变量赋默认值），c.解析 初始化： 给类的静态变量赋初值 只有在真正使用对应的类时，才会触发初始化 如（ 当前类是启动类即 main函数所在类，直接进行new 操作，访问静态属性、访问静态方法，用反射访问类，初始化一个类的子类等.） 123456789// 饿汉模式 class HungrySingleton&#123; private static HungrySingleton instance=new HungrySingleton(); private HungrySingleton()&#123; &#125; public static HungrySingleton getInstance() &#123; return instance; &#125;&#125; 3.静态内部类 本质上是利用类的加载机制来保证线程安全 只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一 种形式。123456789class InnerClassSingleton&#123; private static class InnerClassHolder&#123; private static InnerClassSingleton instance= new InnerClassSingleton(); &#125; private InnerClassSingleton()&#123; &#125; public static InnerClassSingleton getInstance()&#123; return InnerClassHolder.instance; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://shensongpeng.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"懒加载","slug":"懒加载","permalink":"https://shensongpeng.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"}]},{"title":"mysite","slug":"mysite","date":"2021-07-09T04:40:33.000Z","updated":"2021-07-12T08:35:43.803Z","comments":true,"path":"2021/07/09/mysite/","link":"","permalink":"https://shensongpeng.github.io/2021/07/09/mysite/","excerpt":"","text":"","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://shensongpeng.github.io/categories/leetcode/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://shensongpeng.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"测试1","slug":"测试1","permalink":"https://shensongpeng.github.io/tags/%E6%B5%8B%E8%AF%951/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-09T04:39:55.408Z","updated":"2021-07-12T02:55:38.647Z","comments":true,"path":"2021/07/09/hello-world/","link":"","permalink":"https://shensongpeng.github.io/2021/07/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1$ hexo","categories":[],"tags":[]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://shensongpeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"leetcode","slug":"leetcode","permalink":"https://shensongpeng.github.io/categories/leetcode/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://shensongpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"索引","slug":"索引","permalink":"https://shensongpeng.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shensongpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"B+数","slug":"B-数","permalink":"https://shensongpeng.github.io/tags/B-%E6%95%B0/"},{"name":"Hash","slug":"Hash","permalink":"https://shensongpeng.github.io/tags/Hash/"},{"name":"范式","slug":"范式","permalink":"https://shensongpeng.github.io/tags/%E8%8C%83%E5%BC%8F/"},{"name":"设计模式","slug":"设计模式","permalink":"https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"原型模式","slug":"原型模式","permalink":"https://shensongpeng.github.io/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Prototype","slug":"Prototype","permalink":"https://shensongpeng.github.io/tags/Prototype/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://shensongpeng.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://shensongpeng.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"观察者模式","slug":"观察者模式","permalink":"https://shensongpeng.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"Observer","slug":"Observer","permalink":"https://shensongpeng.github.io/tags/Observer/"},{"name":"模板方法","slug":"模板方法","permalink":"https://shensongpeng.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"},{"name":"单例模式","slug":"单例模式","permalink":"https://shensongpeng.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"懒加载","slug":"懒加载","permalink":"https://shensongpeng.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"},{"name":"测试","slug":"测试","permalink":"https://shensongpeng.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"测试1","slug":"测试1","permalink":"https://shensongpeng.github.io/tags/%E6%B5%8B%E8%AF%951/"}]}