<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>松松闲谈</title>
  
  
  <link href="https://shensongpeng.github.io/atom.xml" rel="self"/>
  
  <link href="https://shensongpeng.github.io/"/>
  <updated>2021-07-20T05:59:45.177Z</updated>
  <id>https://shensongpeng.github.io/</id>
  
  <author>
    <name>shensongpeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM基础故障处理工具</title>
    <link href="https://shensongpeng.github.io/2021/07/19/JVM%E5%9F%BA%E7%A1%80%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://shensongpeng.github.io/2021/07/19/JVM%E5%9F%BA%E7%A1%80%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2021-07-19T05:51:53.000Z</published>
    <updated>2021-07-20T05:59:45.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h1><h2 id="1-jdk小工具命名方式"><a href="#1-jdk小工具命名方式" class="headerlink" title="1.jdk小工具命名方式"></a>1.jdk小工具命名方式</h2><p>JDK的很多小工具的名字都参考了UNIX命令的命名方式。</p><h2 id="2-jps（JVM-Process-Status-Tool）"><a href="#2-jps（JVM-Process-Status-Tool）" class="headerlink" title="2.jps（JVM Process Status Tool）"></a>2.jps（JVM Process Status Tool）</h2><p>jps是虚拟机进程状况工具。jps名字和UNIX的ps命令类似，它的功能也和ps命令类似：</p><ul><li>可以列出正在运行的虚拟机进程，</li><li>显示虚拟机执行主类（Main Class，main()函数所在的类）名称</li><li>以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。</li></ul><h3 id="2-1jps命令格式"><a href="#2-1jps命令格式" class="headerlink" title="2.1jps命令格式"></a>2.1jps命令格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-q</td><td>只输出LVMID，省略主类的名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main（）函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果进程执行的是jar包，则输出JAR路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时的JVM参数</td></tr></tbody></table><p>jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，参数hostid为RMI注册表中注册的主机名。</p><h3 id="2-2jps执行样例"><a href="#2-2jps执行样例" class="headerlink" title="2.2jps执行样例"></a>2.2jps执行样例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br><span class="line"></span><br><span class="line">4672 sun.tools.jps.Jps</span><br><span class="line">7364 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">24440 C:/Program</span><br><span class="line">28808 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">5128</span><br></pre></td></tr></table></figure><h2 id="3-jstat-JVM-Statistics-Monitoring-Tool"><a href="#3-jstat-JVM-Statistics-Monitoring-Tool" class="headerlink" title="3.jstat (JVM Statistics Monitoring Tool )"></a>3.jstat (JVM Statistics Monitoring Tool )</h2><p>jstat是jdk自带的虚拟机统计信息监视工具。用于监视虚拟机各种运行状态信息的工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾手机、即时编译等运行时数据，在只提供了控制台的服务器上，它将是在软件运行期间定位虚拟机性能问题的常用工具。</p><h3 id="3-1命令格式"><a href="#3-1命令格式" class="headerlink" title="3.1命令格式"></a>3.1命令格式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option vmid interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure><p>对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的；如果是远程虚拟机进程，那VMID的格式应当是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure><p>参数interval和count代表查询间隔和次数，如果省略这2个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：<br>jstat -gc 2764 250 20<br>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。详细请参考表4-2中的描述。</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视类加载、卸载数量、总空间以及类加载所消耗的时间</td></tr><tr><td>-gc</td><td>监视java堆情况，包括Eden区、survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息</td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但输出主要关注以使用空间占总空间的百分比</td></tr><tr><td>-gccause</td><td>监视内容与-gcutil功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td></tr><tr><td>-gcnew</td><td>监视新生代垃圾收集状况</td></tr><tr><td>-gcnewcapacity</td><td>监视内容与-gc基本相同，但输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcold</td><td>监视老年代垃圾收集状况</td></tr><tr><td>-gcoldcapacity</td><td>监视内容与-gcold基本相同，但输出主要关注使用到的最大、最小空间</td></tr><tr><td>-gcmetacapacity</td><td>输出元空间使用到的最大、最小空间</td></tr><tr><td>-compiler</td><td>输出即时编译器编译过的方法，耗时等信息</td></tr><tr><td>-printcompilation</td><td>输出已经被即时编译的方法</td></tr></tbody></table><table><thead><tr><th>缩写</th><th>描述</th></tr></thead><tbody><tr><td>S0C</td><td>第一个幸存区的大小</td></tr><tr><td>S1C</td><td>第二个幸存区的大小</td></tr><tr><td>S0U</td><td>第一个幸存区的使用大小</td></tr><tr><td>S1U</td><td>第二个幸存区的使用大小</td></tr><tr><td>EC</td><td>伊甸园区的大小</td></tr><tr><td>EU</td><td>伊甸园区的使用大小</td></tr><tr><td>OC</td><td>老年代大小</td></tr><tr><td>OU</td><td>老年代使用大小</td></tr><tr><td>MC</td><td>方法区大小(元空间)</td></tr><tr><td>MU</td><td>方法区使用大小</td></tr><tr><td>CCSC</td><td>压缩类空间大小</td></tr><tr><td>CCSU</td><td>CCSU:压缩类空间使用大小</td></tr><tr><td>YGC</td><td>年轻代垃圾回收次数</td></tr><tr><td>YGCT</td><td>年轻代垃圾回收消耗时间，单位s</td></tr><tr><td>FGC</td><td>老年代垃圾回收次数</td></tr><tr><td>FGCT</td><td>老年代垃圾回收消耗时间，单位s</td></tr><tr><td>GCT</td><td>垃圾回收消耗总时间，单位s</td></tr></tbody></table><h2 id="3-jinfo-Java配置信息工具"><a href="#3-jinfo-Java配置信息工具" class="headerlink" title="3.jinfo Java配置信息工具"></a>3.jinfo Java配置信息工具</h2><h2 id="4-jmap-java内存映像工具"><a href="#4-jmap-java内存映像工具" class="headerlink" title="4.jmap java内存映像工具"></a>4.jmap java内存映像工具</h2><h2 id="5-jhat-虚拟机堆转储快照分析工具"><a href="#5-jhat-虚拟机堆转储快照分析工具" class="headerlink" title="5.jhat 虚拟机堆转储快照分析工具"></a>5.jhat 虚拟机堆转储快照分析工具</h2><h2 id="6-jstack-Java堆栈跟踪工具"><a href="#6-jstack-Java堆栈跟踪工具" class="headerlink" title="6.jstack Java堆栈跟踪工具"></a>6.jstack Java堆栈跟踪工具</h2><h1 id="基础工具总结"><a href="#基础工具总结" class="headerlink" title="基础工具总结"></a>基础工具总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础故障处理工具&quot;&gt;&lt;a href=&quot;#基础故障处理工具&quot; class=&quot;headerlink&quot; title=&quot;基础故障处理工具&quot;&gt;&lt;/a&gt;基础故障处理工具&lt;/h1&gt;&lt;h2 id=&quot;1-jdk小工具命名方式&quot;&gt;&lt;a href=&quot;#1-jdk小工具命名方式&quot; cla</summary>
      
    
    
    
    <category term="jvm" scheme="https://shensongpeng.github.io/categories/jvm/"/>
    
    
    <category term="jvm" scheme="https://shensongpeng.github.io/tags/jvm/"/>
    
    <category term="基础故障" scheme="https://shensongpeng.github.io/tags/%E5%9F%BA%E7%A1%80%E6%95%85%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>5815. 扣分后的最大得分</title>
    <link href="https://shensongpeng.github.io/2021/07/18/5815-%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/"/>
    <id>https://shensongpeng.github.io/2021/07/18/5815-%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/</id>
    <published>2021-07-18T06:21:40.499Z</published>
    <updated>2021-07-18T10:40:49.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扣分后的最大得分"><a href="#扣分后的最大得分" class="headerlink" title="扣分后的最大得分"></a>扣分后的最大得分</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 m x n 的整数矩阵 points （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。</p><p>你的得分方式为：每一行 中选取一个格子，选中坐标为 (r, c) 的格子会给你的总得分 增加 points[r][c] 。</p><p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 r 和 r + 1 （其中 0 &lt;= r &lt; m - 1），选中坐标为 (r, c1) 和 (r + 1, c2) 的格子，你的总得分 减少 abs(c1 - c2) 。</p><p>请你返回你能得到的 最大 得分。</p><p>abs(x) 定义为：</p><ul><li>如果 x &gt;= 0 ，那么值为 x 。</li><li>如果 x &lt; 0 ，那么值为 -x 。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>回溯</li><li>动态规划</li><li>动态规划优化</li></ul><p>选择问题一般都可以用回溯的思路进行解决，但是回溯的时间复杂度很大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        dfs(points,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] points,<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= points.length) &#123;</span><br><span class="line">            res = Math.max(res,score);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points[row].length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newScore = score + points[row][i];</span><br><span class="line">            <span class="keyword">if</span> (row &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                newScore -= Math.abs(col - i);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(points,row+<span class="number">1</span>,i,newScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划解法<br>dp[i][j] 代表i行j列的最大得分</p><p>状态转移方程：<br>dp[i][j] = max{ dp[i-1][k] + points[i][j] + abs(j-k) ,k = 0-n n为points列长度}<br>时间复杂度？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = points.length;</span><br><span class="line">        <span class="keyword">int</span> n = points[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = points[<span class="number">0</span>][i];</span><br><span class="line">            result = Math.max(result,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">long</span> score = points[i][j] + dp[i-<span class="number">1</span>][k] - Math.abs(j-k);</span><br><span class="line">                    dp[i][j] = Math.max(score,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>动态规划优化解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;扣分后的最大得分&quot;&gt;&lt;a href=&quot;#扣分后的最大得分&quot; class=&quot;headerlink&quot; title=&quot;扣分后的最大得分&quot;&gt;&lt;/a&gt;扣分后的最大得分&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="leetcode" scheme="https://shensongpeng.github.io/categories/leetcode/"/>
    
    
    <category term="周赛" scheme="https://shensongpeng.github.io/tags/%E5%91%A8%E8%B5%9B/"/>
    
    <category term="面试" scheme="https://shensongpeng.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="中等" scheme="https://shensongpeng.github.io/tags/%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>面试题 10.02. 变位词组</title>
    <link href="https://shensongpeng.github.io/2021/07/17/%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>https://shensongpeng.github.io/2021/07/17/%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2021-07-17T14:48:34.000Z</published>
    <updated>2021-07-18T02:31:51.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a>面试题 10.02. 变位词组</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul><h3 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h3><h3 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h3><ul><li>如何识别字符串是同一个变位词？</li><li>同一个变位词如何快速加入到对应的数组中？</li></ul><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>对于第一个问题：</p><p>对将变位词进行计数排序，返回排序好的字符串，将返回的字符串作为哈希表的key，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        HashMap&lt;String ,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( String str: strs) &#123;</span><br><span class="line">            String key = count(str);</span><br><span class="line">            List&lt;String&gt; list;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                result.add(list);</span><br><span class="line">                map.put(key,list);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                list = map.get(key);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">count</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            bit[c -<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bit[i]; j++) &#123;</span><br><span class="line">                stringBuilder.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试题-10-02-变位词组&quot;&gt;&lt;a href=&quot;#面试题-10-02-变位词组&quot; class=&quot;headerlink&quot; title=&quot;面试题 10.02. 变位词组&quot;&gt;&lt;/a&gt;面试题 10.02. 变位词组&lt;/h1&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://shensongpeng.github.io/categories/leetcode/"/>
    
    
    <category term="面试题" scheme="https://shensongpeng.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://shensongpeng.github.io/tags/leetcode/"/>
    
    <category term="每日一题" scheme="https://shensongpeng.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="https://shensongpeng.github.io/2021/07/15/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>https://shensongpeng.github.io/2021/07/15/mysql%E7%B4%A2%E5%BC%95/</id>
    <published>2021-07-15T03:38:47.000Z</published>
    <updated>2021-07-15T03:38:47.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h2><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><p>索引是帮助Mysql高效获取数据的排好序的数据结构。</p><p>索引可以用的数据结构有：</p><ul><li>二叉树</li><li>红黑树</li><li>Hash表</li><li>B-Tree</li></ul><h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><ul><li><p>叶子节点具有相同的深度，叶节点的指针为空</p></li><li><p>所有索引元素不重复</p></li><li><p>节点中的数据索引从左往右递增排列</p><h3 id="B-树（B树变种）"><a href="#B-树（B树变种）" class="headerlink" title="B+树（B树变种）"></a>B+树（B树变种）</h3></li><li><p>非叶子节点不存储data，只存储索引（索引会冗余），因此每页可以存储更多索引</p></li><li><p>叶子节点包含所有索引字段</p></li><li><p>叶子节点用指针连接，提高区间访问能力</p></li></ul><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>索引文件和数据文件在一起的是聚集索引。</p><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>索引文件和数据文件分离的是非聚集索引</p><h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>InnoDb索引是聚集索引。表数据本身就是按照B+树结构存储的一个索引结构文件。因此InnDB存储的表必须存在主键。<br>辅助索引使用的非聚集索引。存储的是主键值。聚集索引的叶子节点包含了完整的数据记录。</p><h4 id="为何InonoDB非主键索引结构叶子节点存储的是主键值"><a href="#为何InonoDB非主键索引结构叶子节点存储的是主键值" class="headerlink" title="为何InonoDB非主键索引结构叶子节点存储的是主键值"></a>为何InonoDB非主键索引结构叶子节点存储的是主键值</h4><p>非主键索引叶子节点存储主键而不是存储数据是从两方面考虑。一是如果存储数据数据的更新删除添加操作会存在数据不一致问题。<br>维护数据一致性会很复杂。二是会浪费大量空间。</p><h4 id="为什么InnoDb表必须有主键且推荐使用整型的自增主键"><a href="#为什么InnoDb表必须有主键且推荐使用整型的自增主键" class="headerlink" title="为什么InnoDb表必须有主键且推荐使用整型的自增主键"></a>为什么InnoDb表必须有主键且推荐使用整型的自增主键</h4><p>表数据本身就是按照B+树结构存储的，因此必须有主键，</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引的存储结构也是采用b+树，索引值是按照构建索引时键的顺序存储。<br>叶子节点存储的是主键值。</p><h4 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h4><p>如果要使用联合索引必须要遵循最左前缀原理使用。比如key（a,b,c）<br>直接使用c是几乎不会走索引的。也就是说要使用联合索引的字段进行查询。<br>在联合索引中这个字段的左侧字段也必须使用。不然不会走索引（覆盖索引例外）。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mysql索引&quot;&gt;&lt;a href=&quot;#mysql索引&quot; class=&quot;headerlink&quot; title=&quot;mysql索引&quot;&gt;&lt;/a&gt;mysql索引&lt;/h2&gt;&lt;h3 id=&quot;索引是什么&quot;&gt;&lt;a href=&quot;#索引是什么&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="数据库" scheme="https://shensongpeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://shensongpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="索引" scheme="https://shensongpeng.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="数据结构" scheme="https://shensongpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="B+数" scheme="https://shensongpeng.github.io/tags/B-%E6%95%B0/"/>
    
    <category term="Hash" scheme="https://shensongpeng.github.io/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>三大范式</title>
    <link href="https://shensongpeng.github.io/2021/07/15/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
    <id>https://shensongpeng.github.io/2021/07/15/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</id>
    <published>2021-07-15T03:33:24.000Z</published>
    <updated>2021-07-15T03:33:24.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="第一范式（1NF）："><a href="#第一范式（1NF）：" class="headerlink" title="第一范式（1NF）："></a>第一范式（1NF）：</h3><p>要求数据库表的每一列都是不可分割的原子数据项。</p><h3 id="第二范式（2NF）："><a href="#第二范式（2NF）：" class="headerlink" title="第二范式（2NF）："></a>第二范式（2NF）：</h3><p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p><p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</p><h3 id="第三范式（3NF）："><a href="#第三范式（3NF）：" class="headerlink" title="第三范式（3NF）："></a>第三范式（3NF）：</h3><p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;三大范式&quot;&gt;&lt;a href=&quot;#三大范式&quot; class=&quot;headerlink&quot; title=&quot;三大范式&quot;&gt;&lt;/a&gt;三大范式&lt;/h2&gt;&lt;h3 id=&quot;第一范式（1NF）：&quot;&gt;&lt;a href=&quot;#第一范式（1NF）：&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="数据库" scheme="https://shensongpeng.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="https://shensongpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="范式" scheme="https://shensongpeng.github.io/tags/%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://shensongpeng.github.io/2021/07/14/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shensongpeng.github.io/2021/07/14/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-14T12:18:04.000Z</published>
    <updated>2021-07-14T12:18:04.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>Cloneable接口/Object#clone方法 详解 </li><li>浅拷贝/深拷贝</li><li>序列化机制实现深拷贝</li></ol><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义:"></a>模式定义:</h2><p>指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>当代码不应该依赖于需要复制的对象的具体类时，请使用Prototype模式。</p><p>优点： </p><ol><li>可以不耦合具体类的情况下克隆对象 </li><li>避免重复的初始化代码</li><li>更方便的构建复杂对象</li></ol><h2 id="Spring源码中的应用"><a href="#Spring源码中的应用" class="headerlink" title="Spring源码中的应用"></a>Spring源码中的应用</h2><ul><li>org.springframework.beans.factory.support.bstractBeanDefinition</li><li>java.util.Arrays</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型模式-Prototype&quot;&gt;&lt;a href=&quot;#原型模式-Prototype&quot; class=&quot;headerlink&quot; title=&quot;原型模式(Prototype)&quot;&gt;&lt;/a&gt;原型模式(Prototype)&lt;/h1&gt;&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="设计模式" scheme="https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="原型模式" scheme="https://shensongpeng.github.io/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Prototype" scheme="https://shensongpeng.github.io/tags/Prototype/"/>
    
    <category term="浅拷贝" scheme="https://shensongpeng.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
    <category term="深拷贝" scheme="https://shensongpeng.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://shensongpeng.github.io/2021/07/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shensongpeng.github.io/2021/07/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-14T12:07:30.000Z</published>
    <updated>2021-07-14T12:07:30.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式(Observer)"></a>观察者模式(Observer)</h1><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题 对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>当更改一个对象的状态可能需要更改其他对象，并且实际的对象集事先 未知或动态更改时，请使用观察者模式。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>符合开闭原则 </li><li>可以在运行时建立对象之间的关系</li></ol><h2 id="jdk-amp-源码中的应用"><a href="#jdk-amp-源码中的应用" class="headerlink" title="jdk&amp;源码中的应用"></a>jdk&amp;源码中的应用</h2><ul><li>JDK: java.util.Observable </li><li>Spring: org.springframework.context.ApplicationListener</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;观察者模式-Observer&quot;&gt;&lt;a href=&quot;#观察者模式-Observer&quot; class=&quot;headerlink&quot; title=&quot;观察者模式(Observer)&quot;&gt;&lt;/a&gt;观察者模式(Observer)&lt;/h1&gt;&lt;h2 id=&quot;模式定义&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="观察者模式" scheme="https://shensongpeng.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="Observer" scheme="https://shensongpeng.github.io/tags/Observer/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式</title>
    <link href="https://shensongpeng.github.io/2021/07/14/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shensongpeng.github.io/2021/07/14/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-14T11:51:04.000Z</published>
    <updated>2021-07-14T11:59:24.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板方法-Template-Method"><a href="#模板方法-Template-Method" class="headerlink" title="模板方法(Template Method)"></a>模板方法(Template Method)</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p><h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass abstractClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">        abstractClass.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个操作的算法骨架</span></span><br><span class="line">        System.out.println(<span class="string">&quot; step 1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; step 2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; step 3&quot;</span>);</span><br><span class="line">        <span class="comment">//步骤延迟</span></span><br><span class="line">        templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subclass step&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>当你想让客户端只扩展算法的特定步骤，而不是整个算法或其结构 时，请使用Template Method模式。 </li><li>当你有几个类包含几乎相同的算法，但有一些细微的差异时，请使用 此模式。</li></ol><p>优点： </p><ol><li>你可以让客户端只覆盖大型算法的某些部分，从而减少算法其他部分<br>发生的更改对它们的影响。</li><li>你可以将重复的代码拖放到超类中。</li></ol><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul><li>javax.servlet.http.HttpServlet </li><li>org.springframework.web.servlet.mvc.AbstractController</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模板方法-Template-Method&quot;&gt;&lt;a href=&quot;#模板方法-Template-Method&quot; class=&quot;headerlink&quot; title=&quot;模板方法(Template Method)&quot;&gt;&lt;/a&gt;模板方法(Template Method)&lt;/h2</summary>
      
    
    
    
    <category term="设计模式" scheme="https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="模板方法" scheme="https://shensongpeng.github.io/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://shensongpeng.github.io/2021/07/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://shensongpeng.github.io/2021/07/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-07-14T10:48:33.000Z</published>
    <updated>2021-07-14T11:44:53.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例设计模式（Singleton）"><a href="#单例设计模式（Singleton）" class="headerlink" title="单例设计模式（Singleton）"></a>单例设计模式（Singleton）</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>模式定义/应用场景/类图分析 </li><li>字节码知识/字节码指令重排序 </li><li>类加载机制 </li><li>JVM序列化机制</li><li>单例模式在Spring框架 &amp; JDK源码中的应用</li></ol><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>保证一个类只有一个实例，并且提供一个全局的访问点</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>重量级对象。不需要单个实例，如线程池，数据库连接池</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1-懒汉模式"><a href="#1-懒汉模式" class="headerlink" title="1.懒汉模式"></a>1.懒汉模式</h3><p>懒汉模式：延迟加载， 只有在真正使用的时候，才开始实例化。 </p><p>存在问题：</p><ul><li>线程安全问题 </li><li>double check 加锁优化 </li><li>编译器(JIT),CPU 有可能对指令进行重排序，导致使用到尚未初始化 的实例，可以通过添加volatile 关键字进行修饰，</li></ul><p>对于volatile 修饰的字段，可以防止指令重排。（具体原理后续文章展开）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123; </span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123; </span><br><span class="line">                    instance=<span class="keyword">new</span> LazySingleton(); </span><br><span class="line">            <span class="comment">// 字节码层 </span></span><br><span class="line">            <span class="comment">// JIT ， CPU 有可能对如下指令进行重排序</span></span><br><span class="line">            <span class="comment">// 1 .分配空间 </span></span><br><span class="line">            <span class="comment">// 2 .初始化 </span></span><br><span class="line">            <span class="comment">// 3 .引用赋值</span></span><br><span class="line">            <span class="comment">// 如重排序后的结果为如下 </span></span><br><span class="line">            <span class="comment">// 1 .分配空间 </span></span><br><span class="line">            <span class="comment">// 3 .引用赋值 如果在当前指令执行完，有其他线程来获取实例，将拿到尚未初始化好的实例 </span></span><br><span class="line">            <span class="comment">// 2 .初始化 </span></span><br><span class="line">                &#125; </span><br><span class="line">             &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-饿汉模式："><a href="#2-饿汉模式：" class="headerlink" title="2.饿汉模式："></a>2.饿汉模式：</h3><p>类加载的初始化阶段就完成了实例的初始化。本质上就是借助于jvm 类加载机制，保证实例的唯一性（初始化过程只会执行一次）及线程安全（JVM以同步的形式来完成类加载的整个过程）。 </p><p>类加载过程： </p><ol><li>加载二进制数据到内存中， 生成对应的Class数据结构， </li><li>连接： a. 验证， b.准备（给类的静态成员变量赋默认值），c.解析 </li><li>初始化： 给类的静态变量赋初值</li></ol><p>只有在真正使用对应的类时，才会触发初始化 如（ 当前类是启动类即 main函数所在类，直接进行new 操作，访问静态属性、访问静态方法，用反射访问类，初始化一个类的子类等.）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance=<span class="keyword">new</span> HungrySingleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3.静态内部类"></a>3.静态内部类</h3><ol><li>本质上是利用类的加载机制来保证线程安全 </li><li>只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一 种形式。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassHolder</span></span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> InnerClassSingleton instance= <span class="keyword">new</span> InnerClassSingleton(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span><span class="params">()</span></span>&#123;  &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> InnerClassHolder.instance;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单例设计模式（Singleton）&quot;&gt;&lt;a href=&quot;#单例设计模式（Singleton）&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式（Singleton）&quot;&gt;&lt;/a&gt;单例设计模式（Singleton）&lt;/h2&gt;&lt;h3 id=&quot;知识点&quot;&gt;</summary>
      
    
    
    
    <category term="设计模式" scheme="https://shensongpeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="https://shensongpeng.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="设计模式" scheme="https://shensongpeng.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="懒加载" scheme="https://shensongpeng.github.io/tags/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://shensongpeng.github.io/2021/07/09/hello-world/"/>
    <id>https://shensongpeng.github.io/2021/07/09/hello-world/</id>
    <published>2021-07-09T04:39:55.408Z</published>
    <updated>2021-07-12T02:55:38.647Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
