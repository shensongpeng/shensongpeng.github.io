<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单例模式</title>
    <url>/2021/07/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例设计模式（Singleton）"><a href="#单例设计模式（Singleton）" class="headerlink" title="单例设计模式（Singleton）"></a>单例设计模式（Singleton）</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>模式定义/应用场景/类图分析 </li>
<li>字节码知识/字节码指令重排序 </li>
<li>类加载机制 </li>
<li>JVM序列化机制</li>
<li>单例模式在Spring框架 &amp; JDK源码中的应用</li>
</ol>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>保证一个类只有一个实例，并且提供一个全局的访问点</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>重量级对象。不需要单个实例，如线程池，数据库连接池</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1-懒汉模式"><a href="#1-懒汉模式" class="headerlink" title="1.懒汉模式"></a>1.懒汉模式</h3><p>懒汉模式：延迟加载， 只有在真正使用的时候，才开始实例化。 </p>
<p>存在问题：</p>
<ul>
<li>线程安全问题 </li>
<li>double check 加锁优化 </li>
<li>编译器(JIT),CPU 有可能对指令进行重排序，导致使用到尚未初始化 的实例，可以通过添加volatile 关键字进行修饰，</li>
</ul>
<p>对于volatile 修饰的字段，可以防止指令重排。（具体原理后续文章展开）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123; </span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123; </span><br><span class="line">                    instance=<span class="keyword">new</span> LazySingleton(); </span><br><span class="line">            <span class="comment">// 字节码层 </span></span><br><span class="line">            <span class="comment">// JIT ， CPU 有可能对如下指令进行重排序</span></span><br><span class="line">            <span class="comment">// 1 .分配空间 </span></span><br><span class="line">            <span class="comment">// 2 .初始化 </span></span><br><span class="line">            <span class="comment">// 3 .引用赋值</span></span><br><span class="line">            <span class="comment">// 如重排序后的结果为如下 </span></span><br><span class="line">            <span class="comment">// 1 .分配空间 </span></span><br><span class="line">            <span class="comment">// 3 .引用赋值 如果在当前指令执行完，有其他线程来获取实例，将拿到尚未初始化好的实例 </span></span><br><span class="line">            <span class="comment">// 2 .初始化 </span></span><br><span class="line">                &#125; </span><br><span class="line">             &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-饿汉模式："><a href="#2-饿汉模式：" class="headerlink" title="2.饿汉模式："></a>2.饿汉模式：</h3><p>类加载的初始化阶段就完成了实例的初始化。本质上就是借助于jvm 类加载机制，保证实例的唯一性（初始化过程只会执行一次）及线程安全（JVM以同步的形式来完成类加载的整个过程）。 </p>
<p>类加载过程： </p>
<ol>
<li>加载二进制数据到内存中， 生成对应的Class数据结构， </li>
<li>连接： a. 验证， b.准备（给类的静态成员变量赋默认值），c.解析 </li>
<li>初始化： 给类的静态变量赋初值</li>
</ol>
<p>只有在真正使用对应的类时，才会触发初始化 如（ 当前类是启动类即 main函数所在类，直接进行new 操作，访问静态属性、访问静态方法，用反射访问类，初始化一个类的子类等.）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance=<span class="keyword">new</span> HungrySingleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3.静态内部类"></a>3.静态内部类</h3><ol>
<li>本质上是利用类的加载机制来保证线程安全 </li>
<li>只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一 种形式。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassHolder</span></span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> InnerClassSingleton instance= <span class="keyword">new</span> InnerClassSingleton(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span><span class="params">()</span></span>&#123;  &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> InnerClassHolder.instance;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>设计模式</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2021/07/14/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="模板方法-Template-Method"><a href="#模板方法-Template-Method" class="headerlink" title="模板方法(Template Method)"></a>模板方法(Template Method)</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>
<h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass abstractClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">        abstractClass.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个操作的算法骨架</span></span><br><span class="line">        System.out.println(<span class="string">&quot; step 1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; step 2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; step 3&quot;</span>);</span><br><span class="line">        <span class="comment">//步骤延迟</span></span><br><span class="line">        templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subclass step&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>当你想让客户端只扩展算法的特定步骤，而不是整个算法或其结构 时，请使用Template Method模式。 </li>
<li>当你有几个类包含几乎相同的算法，但有一些细微的差异时，请使用 此模式。</li>
</ol>
<p>优点： </p>
<ol>
<li>你可以让客户端只覆盖大型算法的某些部分，从而减少算法其他部分<br>发生的更改对它们的影响。</li>
<li>你可以将重复的代码拖放到超类中。</li>
</ol>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul>
<li>javax.servlet.http.HttpServlet </li>
<li>org.springframework.web.servlet.mvc.AbstractController</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/07/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式(Observer)"></a>观察者模式(Observer)</h1><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题 对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>当更改一个对象的状态可能需要更改其他对象，并且实际的对象集事先 未知或动态更改时，请使用观察者模式。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>符合开闭原则 </li>
<li>可以在运行时建立对象之间的关系</li>
</ol>
<h2 id="jdk-amp-源码中的应用"><a href="#jdk-amp-源码中的应用" class="headerlink" title="jdk&amp;源码中的应用"></a>jdk&amp;源码中的应用</h2><ul>
<li>JDK: java.util.Observable </li>
<li>Spring: org.springframework.context.ApplicationListener</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
        <tag>Observer</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2021/07/14/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>Cloneable接口/Object#clone方法 详解 </li>
<li>浅拷贝/深拷贝</li>
<li>序列化机制实现深拷贝</li>
</ol>
<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义:"></a>模式定义:</h2><p>指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>当代码不应该依赖于需要复制的对象的具体类时，请使用Prototype模式。</p>
<p>优点： </p>
<ol>
<li>可以不耦合具体类的情况下克隆对象 </li>
<li>避免重复的初始化代码</li>
<li>更方便的构建复杂对象</li>
</ol>
<h2 id="Spring源码中的应用"><a href="#Spring源码中的应用" class="headerlink" title="Spring源码中的应用"></a>Spring源码中的应用</h2><ul>
<li>org.springframework.beans.factory.support.bstractBeanDefinition</li>
<li>java.util.Arrays</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
        <tag>Prototype</tag>
        <tag>浅拷贝</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>三大范式</title>
    <url>/2021/07/15/%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="第一范式（1NF）："><a href="#第一范式（1NF）：" class="headerlink" title="第一范式（1NF）："></a>第一范式（1NF）：</h3><p>要求数据库表的每一列都是不可分割的原子数据项。</p>
<h3 id="第二范式（2NF）："><a href="#第二范式（2NF）：" class="headerlink" title="第二范式（2NF）："></a>第二范式（2NF）：</h3><p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>
<p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</p>
<h3 id="第三范式（3NF）："><a href="#第三范式（3NF）：" class="headerlink" title="第三范式（3NF）："></a>第三范式（3NF）：</h3><p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>范式</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引</title>
    <url>/2021/07/15/mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h2><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><p>索引是帮助Mysql高效获取数据的排好序的数据结构。</p>
<p>索引可以用的数据结构有：</p>
<ul>
<li>二叉树</li>
<li>红黑树</li>
<li>Hash表</li>
<li>B-Tree</li>
</ul>
<h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><ul>
<li><p>叶子节点具有相同的深度，叶节点的指针为空</p>
</li>
<li><p>所有索引元素不重复</p>
</li>
<li><p>节点中的数据索引从左往右递增排列</p>
<h3 id="B-树（B树变种）"><a href="#B-树（B树变种）" class="headerlink" title="B+树（B树变种）"></a>B+树（B树变种）</h3></li>
<li><p>非叶子节点不存储data，只存储索引（索引会冗余），因此每页可以存储更多索引</p>
</li>
<li><p>叶子节点包含所有索引字段</p>
</li>
<li><p>叶子节点用指针连接，提高区间访问能力</p>
</li>
</ul>
<h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>索引文件和数据文件在一起的是聚集索引。</p>
<h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>索引文件和数据文件分离的是非聚集索引</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>InnoDb索引是聚集索引。表数据本身就是按照B+树结构存储的一个索引结构文件。因此InnDB存储的表必须存在主键。<br>辅助索引使用的非聚集索引。存储的是主键值。聚集索引的叶子节点包含了完整的数据记录。</p>
<h4 id="为何InonoDB非主键索引结构叶子节点存储的是主键值"><a href="#为何InonoDB非主键索引结构叶子节点存储的是主键值" class="headerlink" title="为何InonoDB非主键索引结构叶子节点存储的是主键值"></a>为何InonoDB非主键索引结构叶子节点存储的是主键值</h4><p>非主键索引叶子节点存储主键而不是存储数据是从两方面考虑。一是如果存储数据数据的更新删除添加操作会存在数据不一致问题。<br>维护数据一致性会很复杂。二是会浪费大量空间。</p>
<h4 id="为什么InnoDb表必须有主键且推荐使用整型的自增主键"><a href="#为什么InnoDb表必须有主键且推荐使用整型的自增主键" class="headerlink" title="为什么InnoDb表必须有主键且推荐使用整型的自增主键"></a>为什么InnoDb表必须有主键且推荐使用整型的自增主键</h4><p>表数据本身就是按照B+树结构存储的，因此必须有主键，</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引的存储结构也是采用b+树，索引值是按照构建索引时键的顺序存储。<br>叶子节点存储的是主键值。</p>
<h4 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h4><p>如果要使用联合索引必须要遵循最左前缀原理使用。比如key（a,b,c）<br>直接使用c是几乎不会走索引的。也就是说要使用联合索引的字段进行查询。<br>在联合索引中这个字段的左侧字段也必须使用。不然不会走索引（覆盖索引例外）。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>数据结构</tag>
        <tag>B+数</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 10.02. 变位词组</title>
    <url>/2021/07/17/%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a>面试题 10.02. 变位词组</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<h3 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h3><h3 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h3><ul>
<li>如何识别字符串是同一个变位词？</li>
<li>同一个变位词如何快速加入到对应的数组中？</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>对于第一个问题：</p>
<p>对将变位词进行计数排序，返回排序好的字符串，将返回的字符串作为哈希表的key，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        HashMap&lt;String ,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( String str: strs) &#123;</span><br><span class="line">            String key = count(str);</span><br><span class="line">            List&lt;String&gt; list;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                result.add(list);</span><br><span class="line">                map.put(key,list);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                list = map.get(key);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">count</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            bit[c -<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bit[i]; j++) &#123;</span><br><span class="line">                stringBuilder.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>leetcode</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>5815. 扣分后的最大得分</title>
    <url>/2021/07/18/5815-%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/</url>
    <content><![CDATA[<h1 id="扣分后的最大得分"><a href="#扣分后的最大得分" class="headerlink" title="扣分后的最大得分"></a>扣分后的最大得分</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 m x n 的整数矩阵 points （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。</p>
<p>你的得分方式为：每一行 中选取一个格子，选中坐标为 (r, c) 的格子会给你的总得分 增加 points[r][c] 。</p>
<p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 r 和 r + 1 （其中 0 &lt;= r &lt; m - 1），选中坐标为 (r, c1) 和 (r + 1, c2) 的格子，你的总得分 减少 abs(c1 - c2) 。</p>
<p>请你返回你能得到的 最大 得分。</p>
<p>abs(x) 定义为：</p>
<ul>
<li>如果 x &gt;= 0 ，那么值为 x 。</li>
<li>如果 x &lt; 0 ，那么值为 -x 。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>回溯</li>
<li>动态规划</li>
<li>动态规划优化</li>
</ul>
<p>选择问题一般都可以用回溯的思路进行解决，但是回溯的时间复杂度很大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        dfs(points,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] points,<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= points.length) &#123;</span><br><span class="line">            res = Math.max(res,score);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points[row].length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newScore = score + points[row][i];</span><br><span class="line">            <span class="keyword">if</span> (row &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                newScore -= Math.abs(col - i);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(points,row+<span class="number">1</span>,i,newScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划解法<br>dp[i][j] 代表i行j列的最大得分</p>
<p>状态转移方程：<br>dp[i][j] = max{ dp[i-1][k] + points[i][j] + abs(j-k) ,k = 0-n n为points列长度}<br>时间复杂度？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = points.length;</span><br><span class="line">        <span class="keyword">int</span> n = points[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = points[<span class="number">0</span>][i];</span><br><span class="line">            result = Math.max(result,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">long</span> score = points[i][j] + dp[i-<span class="number">1</span>][k] - Math.abs(j-k);</span><br><span class="line">                    dp[i][j] = Math.max(score,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动态规划优化解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>面试</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM基础故障处理工具</title>
    <url>/2021/07/19/JVM%E5%9F%BA%E7%A1%80%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h1><h2 id="1-jdk小工具命名方式"><a href="#1-jdk小工具命名方式" class="headerlink" title="1.jdk小工具命名方式"></a>1.jdk小工具命名方式</h2><p>JDK的很多小工具的名字都参考了UNIX命令的命名方式。</p>
<h2 id="2-jps（JVM-Process-Status-Tool）"><a href="#2-jps（JVM-Process-Status-Tool）" class="headerlink" title="2.jps（JVM Process Status Tool）"></a>2.jps（JVM Process Status Tool）</h2><p>jps是虚拟机进程状况工具。jps名字和UNIX的ps命令类似，它的功能也和ps命令类似：</p>
<ul>
<li>可以列出正在运行的虚拟机进程，</li>
<li>显示虚拟机执行主类（Main Class，main()函数所在的类）名称</li>
<li>以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。</li>
</ul>
<h3 id="2-1jps命令格式"><a href="#2-1jps命令格式" class="headerlink" title="2.1jps命令格式"></a>2.1jps命令格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-q</td>
<td>只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机进程启动时传递给主类main（）函数的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主类的全名，如果进程执行的是jar包，则输出JAR路径</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时的JVM参数</td>
</tr>
</tbody></table>
<p>jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，参数hostid为RMI注册表中注册的主机名。</p>
<h3 id="2-2jps执行样例"><a href="#2-2jps执行样例" class="headerlink" title="2.2jps执行样例"></a>2.2jps执行样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps -l</span><br><span class="line"></span><br><span class="line">4672 sun.tools.jps.Jps</span><br><span class="line">7364 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">24440 C:/Program</span><br><span class="line">28808 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">5128</span><br></pre></td></tr></table></figure>

<h2 id="3-jstat-JVM-Statistics-Monitoring-Tool"><a href="#3-jstat-JVM-Statistics-Monitoring-Tool" class="headerlink" title="3.jstat (JVM Statistics Monitoring Tool )"></a>3.jstat (JVM Statistics Monitoring Tool )</h2><p>jstat是jdk自带的虚拟机统计信息监视工具。用于监视虚拟机各种运行状态信息的工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾手机、即时编译等运行时数据，在只提供了控制台的服务器上，它将是在软件运行期间定位虚拟机性能问题的常用工具。</p>
<h3 id="3-1命令格式"><a href="#3-1命令格式" class="headerlink" title="3.1命令格式"></a>3.1命令格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat [option vmid interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure>
<p>对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的；如果是远程虚拟机进程，那VMID的格式应当是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure>
<p>参数interval和count代表查询间隔和次数，如果省略这2个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：<br>jstat -gc 2764 250 20<br>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。详细请参考表4-2中的描述。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-class</td>
<td>监视类加载、卸载数量、总空间以及类加载所消耗的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视java堆情况，包括Eden区、survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与-gc基本相同，但输出主要关注以使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>监视内容与-gcutil功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代垃圾收集状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代垃圾收集状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与-gcold基本相同，但输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcmetacapacity</td>
<td>输出元空间使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出即时编译器编译过的方法，耗时等信息</td>
</tr>
<tr>
<td>-printcompilation</td>
<td>输出已经被即时编译的方法</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>S0C</td>
<td>第一个幸存区的大小</td>
</tr>
<tr>
<td>S1C</td>
<td>第二个幸存区的大小</td>
</tr>
<tr>
<td>S0U</td>
<td>第一个幸存区的使用大小</td>
</tr>
<tr>
<td>S1U</td>
<td>第二个幸存区的使用大小</td>
</tr>
<tr>
<td>EC</td>
<td>伊甸园区的大小</td>
</tr>
<tr>
<td>EU</td>
<td>伊甸园区的使用大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代大小</td>
</tr>
<tr>
<td>OU</td>
<td>老年代使用大小</td>
</tr>
<tr>
<td>MC</td>
<td>方法区大小(元空间)</td>
</tr>
<tr>
<td>MU</td>
<td>方法区使用大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>CCSU:压缩类空间使用大小</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>年轻代垃圾回收消耗时间，单位s</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代垃圾回收消耗时间，单位s</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收消耗总时间，单位s</td>
</tr>
</tbody></table>
<h2 id="3-jinfo-Java配置信息工具"><a href="#3-jinfo-Java配置信息工具" class="headerlink" title="3.jinfo Java配置信息工具"></a>3.jinfo Java配置信息工具</h2><h2 id="4-jmap-java内存映像工具"><a href="#4-jmap-java内存映像工具" class="headerlink" title="4.jmap java内存映像工具"></a>4.jmap java内存映像工具</h2><h2 id="5-jhat-虚拟机堆转储快照分析工具"><a href="#5-jhat-虚拟机堆转储快照分析工具" class="headerlink" title="5.jhat 虚拟机堆转储快照分析工具"></a>5.jhat 虚拟机堆转储快照分析工具</h2><h2 id="6-jstack-Java堆栈跟踪工具"><a href="#6-jstack-Java堆栈跟踪工具" class="headerlink" title="6.jstack Java堆栈跟踪工具"></a>6.jstack Java堆栈跟踪工具</h2><h1 id="基础工具总结"><a href="#基础工具总结" class="headerlink" title="基础工具总结"></a>基础工具总结</h1>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>基础故障</tag>
      </tags>
  </entry>
  <entry>
    <title>7.20工作记录</title>
    <url>/2021/07/20/7-20%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>创意目前先将物料存放到对象里，之后在确定是否落到数据库</p>
]]></content>
  </entry>
  <entry>
    <title>mysql缓冲池</title>
    <url>/2021/07/20/mysql%E7%BC%93%E5%86%B2%E6%B1%A0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>缓冲池</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集</title>
    <url>/2021/07/21/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="对象已死判断"><a href="#对象已死判断" class="headerlink" title="对象已死判断"></a>对象已死判断</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法实在对象中添加一个引用计数器，每当有一个地方引用他时，计数器就加一；当引用失效时，计数器减一；任何时刻计数器为0的对象就是不可能在被使用的。</p>
<p>引用计数法回占用一些额外的存储空间来进行计数，但是原理简单，判断效率搞。但是看似简单的算法有很多例外的情况需要考虑，譬如单纯的引用计数法无法解决对象之间循环引用的问题，这就需要大量额外处理才能保证正确地工作。</p>
<h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p>对象objA 和 objB都有字段instance，令 ，objB.instance = objA。此外两个对象没有其他引用，实际上两个对象已经不可能在被访问，但是他们互选引用着对方，导致他们的引用计数器不为0，引用计数算法无法对他们进行回收。</p>
<p>代码样例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testGC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>可达性分析（eachability Analysis）的基本思路时通过一系列GC ROOTs 的根对象作为其实节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain）如果这个对象到GC ROOTS没有任何引用链相连，或者说不可达，则证明对象不可能再使用的。</p>
<h4 id="GC-ROOTs的对象"><a href="#GC-ROOTs的对象" class="headerlink" title="GC ROOTs的对象"></a>GC ROOTs的对象</h4><h5 id="固定的GC-ROOTS集合"><a href="#固定的GC-ROOTS集合" class="headerlink" title="固定的GC ROOTS集合"></a>固定的GC ROOTS集合</h5><ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象，比如使用到的参数、局部变量、临时变量等</li>
<li>方法区中类静态属性引用的变量，比如java类的引用类型静态变量</li>
<li>方法区中常量引用的对象，比如字符串常量池（String table）的引用</li>
<li>本地方法栈中JNI（native方法）引用的对象</li>
<li>java虚拟机内部的引用，比如基本数据类型对应的Class对象，常驻异常对象（OutOfMEmoryError NullPointException）等，还有系统类加载器</li>
<li>同步锁持有的对象</li>
<li>java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存</li>
</ul>
<h5 id="非固定的GC-ROOTS"><a href="#非固定的GC-ROOTS" class="headerlink" title="非固定的GC ROOTS"></a>非固定的GC ROOTS</h5><p>根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。（跨代引用问题）</p>
<h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>引用计数算法和可达性分析都是通过引用来判断对象是否存活。一个对象只有“引用”和“引用未”这两种状态在有些情况下不能完全适用。比如缓存这种对象，当内存空间还足够时，能够保留在内存中，如果内存空间进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象。</p>
<p>JDK1.2后引用的概念进行了扩充引用的分类有</p>
<ul>
<li>强引用 Object obj=new Object() 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用 描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用 描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用 也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>垃圾收集算法</tag>
        <tag>对象死亡判断</tag>
      </tags>
  </entry>
</search>
