<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>5815. 扣分后的最大得分</title>
    <url>/2021/07/20/d4c3b12b93ea.html</url>
    <content><![CDATA[<h1 id="扣分后的最大得分"><a href="#扣分后的最大得分" class="headerlink" title="扣分后的最大得分"></a>扣分后的最大得分</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 m x n 的整数矩阵 points （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。</p>
<p>你的得分方式为：每一行 中选取一个格子，选中坐标为 (r, c) 的格子会给你的总得分 增加 points[r][c] 。</p>
<p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 r 和 r + 1 （其中 0 &lt;= r &lt; m - 1），选中坐标为 (r, c1) 和 (r + 1, c2) 的格子，你的总得分 减少 abs(c1 - c2) 。</p>
<p>请你返回你能得到的 最大 得分。</p>
<p>abs(x) 定义为：</p>
<ul>
<li>如果 x &gt;= 0 ，那么值为 x 。</li>
<li>如果 x &lt; 0 ，那么值为 -x 。</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>回溯</li>
<li>动态规划</li>
<li>动态规划优化</li>
</ul>
<p>选择问题一般都可以用回溯的思路进行解决，但是回溯的时间复杂度很大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        dfs(points,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] points,<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= points.length) &#123;</span><br><span class="line">            res = Math.max(res,score);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points[row].length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newScore = score + points[row][i];</span><br><span class="line">            <span class="keyword">if</span> (row &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                newScore -= Math.abs(col - i);</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(points,row+<span class="number">1</span>,i,newScore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划解法<br>dp[i][j] 代表i行j列的最大得分</p>
<p>状态转移方程：<br>dp[i][j] = max{ dp[i-1][k] + points[i][j] + abs(j-k) ,k = 0-n n为points列长度}<br>时间复杂度？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = points.length;</span><br><span class="line">        <span class="keyword">int</span> n = points[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = points[<span class="number">0</span>][i];</span><br><span class="line">            result = Math.max(result,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">long</span> score = points[i][j] + dp[i-<span class="number">1</span>][k] - Math.abs(j-k);</span><br><span class="line">                    dp[i][j] = Math.max(score,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>动态规划优化解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
        <tag>面试</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>7.20工作记录</title>
    <url>/2021/07/20/bd655ac4c4aa.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="87ea0bc58b85f682e567996502ee342eeff884c86a3e342993987defa4c51917">a37ee15e880291744ad1cedfd0d88b1ce090cfb7097944610506bc036b9f2d1f9e176eb5da67e6d1944c63fdac85c1599bb2f9b7bf06a588f6a89312d3fb99361facb6c03a5321bc6274e97f26f35f6369be8dba9b576f4109153a2049cd42969429e86b6c0a28b8771b8390d597081893bdca0be1af71946e0531229695f1b6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里有东西被加密了，需要输入密码查看。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>工作总结</category>
      </categories>
      <tags>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title>7.22work</title>
    <url>/2021/07/22/9c9e226f0329.html</url>
    <content><![CDATA[<p>创意title 取物料的第一条<br>图片取视频封面<br>看marketApi的代码</p>
<p>后续视频看是否需要加表</p>
]]></content>
  </entry>
  <entry>
    <title>HTTP1.1如何优化</title>
    <url>/2021/08/16/dd6d47563dee.html</url>
    <content><![CDATA[<h1 id="三种优化思路"><a href="#三种优化思路" class="headerlink" title="三种优化思路"></a>三种优化思路</h1><ol>
<li>如何避免发HTTP请求</li>
<li>如何减少HTTP请求</li>
<li>如何减少HTTP请求数据大小</li>
</ol>
<h2 id="如何避免发HTTP请求"><a href="#如何避免发HTTP请求" class="headerlink" title="如何避免发HTTP请求"></a>如何避免发HTTP请求</h2><ol>
<li>使用缓存</li>
</ol>
<p>对于一些重复性的请求把请求响应缓存在本地。url作为Key响应作为value，同时设置过期时间。过期后的重复请求在请求时携带摘要，服务端验证将服务端数据和摘要比较看是否修改，没有修改就返回304 NOt Modified。</p>
<h2 id="如何减少HTTP请求"><a href="#如何减少HTTP请求" class="headerlink" title="如何减少HTTP请求"></a>如何减少HTTP请求</h2><ol>
<li>合并请求 （小数据合并到一起请求）</li>
<li>减少重定向次数 </li>
<li>延迟发送请求（按需加载）</li>
</ol>
<h2 id="减少HTTP响应的数据大小"><a href="#减少HTTP响应的数据大小" class="headerlink" title="减少HTTP响应的数据大小"></a>减少HTTP响应的数据大小</h2><ol>
<li>无损压缩</li>
<li>有损压缩</li>
</ol>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP.1</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM基础故障处理工具</title>
    <url>/2021/07/19/97193fbf6df9.html</url>
    <content><![CDATA[<h1 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h1><h2 id="1-jdk小工具命名方式"><a href="#1-jdk小工具命名方式" class="headerlink" title="1.jdk小工具命名方式"></a>1.jdk小工具命名方式</h2><p>JDK的很多小工具的名字都参考了UNIX命令的命名方式。</p>
<h2 id="2-jps（JVM-Process-Status-Tool）"><a href="#2-jps（JVM-Process-Status-Tool）" class="headerlink" title="2.jps（JVM Process Status Tool）"></a>2.jps（JVM Process Status Tool）</h2><p>jps是虚拟机进程状况工具。jps名字和UNIX的ps命令类似，它的功能也和ps命令类似：</p>
<ul>
<li>可以列出正在运行的虚拟机进程，</li>
<li>显示虚拟机执行主类（Main Class，main()函数所在的类）名称</li>
<li>以及这些进程的本地虚拟机唯一ID（LVMID，Local Virtual Machine Identifier）。</li>
</ul>
<h3 id="2-1jps命令格式"><a href="#2-1jps命令格式" class="headerlink" title="2.1jps命令格式"></a>2.1jps命令格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-q</td>
<td>只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机进程启动时传递给主类main（）函数的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主类的全名，如果进程执行的是jar包，则输出JAR路径</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时的JVM参数</td>
</tr>
</tbody></table>
<p>jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，参数hostid为RMI注册表中注册的主机名。</p>
<h3 id="2-2jps执行样例"><a href="#2-2jps执行样例" class="headerlink" title="2.2jps执行样例"></a>2.2jps执行样例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jps -l</span><br><span class="line"></span><br><span class="line">4672 sun.tools.jps.Jps</span><br><span class="line">7364 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">24440 C:/Program</span><br><span class="line">28808 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">5128</span><br></pre></td></tr></table></figure>

<h2 id="3-jstat-JVM-Statistics-Monitoring-Tool"><a href="#3-jstat-JVM-Statistics-Monitoring-Tool" class="headerlink" title="3.jstat (JVM Statistics Monitoring Tool )"></a>3.jstat (JVM Statistics Monitoring Tool )</h2><p>jstat是jdk自带的虚拟机统计信息监视工具。用于监视虚拟机各种运行状态信息的工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾手机、即时编译等运行时数据，在只提供了控制台的服务器上，它将是在软件运行期间定位虚拟机性能问题的常用工具。</p>
<h3 id="3-1命令格式"><a href="#3-1命令格式" class="headerlink" title="3.1命令格式"></a>3.1命令格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jstat [option vmid interval[s|ms] [count]] ]</span><br></pre></td></tr></table></figure>
<p>对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的；如果是远程虚拟机进程，那VMID的格式应当是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[protocol:][//]lvmid[@hostname[:port]/servername]</span><br></pre></td></tr></table></figure>
<p>参数interval和count代表查询间隔和次数，如果省略这2个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：<br>jstat -gc 2764 250 20<br>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。详细请参考表4-2中的描述。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-class</td>
<td>监视类加载、卸载数量、总空间以及类加载所消耗的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视java堆情况，包括Eden区、survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与-gc基本相同，但输出主要关注以使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>监视内容与-gcutil功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代垃圾收集状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代垃圾收集状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与-gcold基本相同，但输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcmetacapacity</td>
<td>输出元空间使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出即时编译器编译过的方法，耗时等信息</td>
</tr>
<tr>
<td>-printcompilation</td>
<td>输出已经被即时编译的方法</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>S0C</td>
<td>第一个幸存区的大小</td>
</tr>
<tr>
<td>S1C</td>
<td>第二个幸存区的大小</td>
</tr>
<tr>
<td>S0U</td>
<td>第一个幸存区的使用大小</td>
</tr>
<tr>
<td>S1U</td>
<td>第二个幸存区的使用大小</td>
</tr>
<tr>
<td>EC</td>
<td>伊甸园区的大小</td>
</tr>
<tr>
<td>EU</td>
<td>伊甸园区的使用大小</td>
</tr>
<tr>
<td>OC</td>
<td>老年代大小</td>
</tr>
<tr>
<td>OU</td>
<td>老年代使用大小</td>
</tr>
<tr>
<td>MC</td>
<td>方法区大小(元空间)</td>
</tr>
<tr>
<td>MU</td>
<td>方法区使用大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>CCSU:压缩类空间使用大小</td>
</tr>
<tr>
<td>YGC</td>
<td>年轻代垃圾回收次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>年轻代垃圾回收消耗时间，单位s</td>
</tr>
<tr>
<td>FGC</td>
<td>老年代垃圾回收次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>老年代垃圾回收消耗时间，单位s</td>
</tr>
<tr>
<td>GCT</td>
<td>垃圾回收消耗总时间，单位s</td>
</tr>
</tbody></table>
<h2 id="3-jinfo-Java配置信息工具"><a href="#3-jinfo-Java配置信息工具" class="headerlink" title="3.jinfo Java配置信息工具"></a>3.jinfo Java配置信息工具</h2><h2 id="4-jmap-java内存映像工具"><a href="#4-jmap-java内存映像工具" class="headerlink" title="4.jmap java内存映像工具"></a>4.jmap java内存映像工具</h2><h2 id="5-jhat-虚拟机堆转储快照分析工具"><a href="#5-jhat-虚拟机堆转储快照分析工具" class="headerlink" title="5.jhat 虚拟机堆转储快照分析工具"></a>5.jhat 虚拟机堆转储快照分析工具</h2><h2 id="6-jstack-Java堆栈跟踪工具"><a href="#6-jstack-Java堆栈跟踪工具" class="headerlink" title="6.jstack Java堆栈跟踪工具"></a>6.jstack Java堆栈跟踪工具</h2><h1 id="基础工具总结"><a href="#基础工具总结" class="headerlink" title="基础工具总结"></a>基础工具总结</h1>]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>基础故障</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC的概念以及优缺点</title>
    <url>/2021/11/16/6498daf82f70.html</url>
    <content><![CDATA[<h1 id="RPC的概念"><a href="#RPC的概念" class="headerlink" title="RPC的概念"></a>RPC的概念</h1><p>RPC(远程过程调用)可以分为两部分：远程过程以及过程调用。远程过程是指每台机器上提供的服务，过程调用就是对远程过程调用以及数据传输。</p>
<h1 id="RPC的优点"><a href="#RPC的优点" class="headerlink" title="RPC的优点"></a>RPC的优点</h1><p>RPC带来的优势其实就是分布式架构带来的优势。在RPC的支持下，可以实现模块的分布式部署，可以实现更好的维护性，扩展性以及协同式开发。</p>
<h1 id="RPC带来的问题"><a href="#RPC带来的问题" class="headerlink" title="RPC带来的问题"></a>RPC带来的问题</h1><p>RPC的出现为构建分布式架构带来了便利，但是分布式系统本身的问题也被暴漏了下来。存在的问题如下：</p>
<ol>
<li>通信延迟</li>
<li>地址空间隔离</li>
<li>局部故障</li>
<li>并发问题</li>
</ol>
<h2 id="1、通信延迟"><a href="#1、通信延迟" class="headerlink" title="1、通信延迟"></a>1、通信延迟</h2><p>跨机器、网络出现的通信延迟的概率一定比同一台机器的进程间通信大。编解码也会带来性能损耗。而且网络通信也是不可靠的会出现乱序、错误、丢数据等问题。</p>
<h2 id="2、地址空间隔离"><a href="#2、地址空间隔离" class="headerlink" title="2、地址空间隔离"></a>2、地址空间隔离</h2><p>内存地址在一台机器上才有效</p>
<h2 id="3、局部故障"><a href="#3、局部故障" class="headerlink" title="3、局部故障"></a>3、局部故障</h2><p>故障的发现和通知需要引入新的组件，故障的类型判断也会变得复杂，比如是网络链路故障还是机器故障，继而会存在数据不一致问题，故障节点和正常节点会出现数据不一致问题。</p>
<h2 id="4、并发问题"><a href="#4、并发问题" class="headerlink" title="4、并发问题"></a>4、并发问题</h2>]]></content>
      <categories>
        <category>RPC</category>
      </categories>
  </entry>
  <entry>
    <title>SYN Flood攻击以及解决方法</title>
    <url>/2021/07/27/f3207c9d4a24.html</url>
    <content><![CDATA[<h1 id="SYN-Flood攻击以及解决方法-Ther-Meng的博客-CSDN博客"><a href="#SYN-Flood攻击以及解决方法-Ther-Meng的博客-CSDN博客" class="headerlink" title="SYN Flood攻击以及解决方法_Ther Meng的博客-CSDN博客"></a>SYN Flood攻击以及解决方法_Ther Meng的博客-CSDN博客</h1><blockquote>
<h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>syn flood攻击最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，…</p>
</blockquote>
<hr>
<p><strong>syn flood攻击</strong></p>
<p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。</p>
<p>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p>
<p>常见的防攻击方法有：</p>
<p><strong>无效连接的监视释放</strong></p>
<p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p>
<p><strong>延缓TCB分配方法</strong></p>
<p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p>
<p><strong>Syn Cache技术</strong></p>
<p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p>
<p><strong>Syn Cookie技术</strong></p>
<p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p>
<p><strong>使用SYN Proxy防火墙</strong></p>
<p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p>
<p><strong>点个赞，点个收藏，评论下更先显温情！</strong></p>
]]></content>
  </entry>
  <entry>
    <title>TCP VS UDP</title>
    <url>/2021/07/27/b949100f3f59.html</url>
    <content><![CDATA[<img src="https://cdn.songsong.ink/blog/images/transationlayer.svg" class="lazyload" data-srcset="https://cdn.songsong.ink/blog/images/transationlayer.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">
<h2 id="TCP和UDP区别："><a href="#TCP和UDP区别：" class="headerlink" title="TCP和UDP区别："></a>TCP和UDP区别：</h2><h3 id="1-连接"><a href="#1-连接" class="headerlink" title="1.连接"></a>1.连接</h3><ul>
<li>TCP是面向连接的传输层协议，需要先建立连接。</li>
<li>UDP是不需要连接的，即刻传输数据<h3 id="2-服务对象"><a href="#2-服务对象" class="headerlink" title="2. 服务对象"></a>2. 服务对象</h3></li>
<li>TCP是点对点连接</li>
<li>UDP支持一对一，一对多，多对多传输<h3 id="3-可靠性"><a href="#3-可靠性" class="headerlink" title="3. 可靠性"></a>3. 可靠性</h3><h3 id="4-拥塞控制-流量控制"><a href="#4-拥塞控制-流量控制" class="headerlink" title="4. 拥塞控制 流量控制"></a>4. 拥塞控制 流量控制</h3><h3 id="5-首部开销"><a href="#5-首部开销" class="headerlink" title="5. 首部开销"></a>5. 首部开销</h3><h3 id="6-传输方式"><a href="#6-传输方式" class="headerlink" title="6. 传输方式"></a>6. 传输方式</h3><h3 id="7-分片不同"><a href="#7-分片不同" class="headerlink" title="7. 分片不同"></a>7. 分片不同</h3><h2 id="TCP和UDP的应用场景"><a href="#TCP和UDP的应用场景" class="headerlink" title="TCP和UDP的应用场景"></a>TCP和UDP的应用场景</h2></li>
</ul>
<p>TCP：文件传输 HTTP HTTPS<br>UDP：视频、音频 DNS、SMP（包比较小）</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>git proxy problem</title>
    <url>/2022/05/15/a61a3351e369.html</url>
    <content><![CDATA[<h3 id="一、在git克隆代码时遇到无法克隆问题"><a href="#一、在git克隆代码时遇到无法克隆问题" class="headerlink" title="一、在git克隆代码时遇到无法克隆问题"></a>一、在git克隆代码时遇到无法克隆问题</h3><p>问题详细提示如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Cloning into &#x27;MUNIT-keras&#x27;...</span><br><span class="line">fatal: unable to access &#x27;https://github.com/shaoanlu/MUNIT-keras.git/&#x27;: OpenSSL SSL_connect: Connection was reset in connection to github.com:443</span><br></pre></td></tr></table></figure>

<h3 id="二、问题的缘由"><a href="#二、问题的缘由" class="headerlink" title="二、问题的缘由"></a>二、问题的缘由</h3><p>之前为git设置了代理，现在通过软路由全局进行代理，可能出现了冲突问题。</p>
<h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><p>取消了之前为git设置的代理</p>
<h3 id="四、相关的命令如下"><a href="#四、相关的命令如下" class="headerlink" title="四、相关的命令如下"></a>四、相关的命令如下</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#查看git配置</span></span></span><br><span class="line">git config --global -l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#取消代理设置</span></span></span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 备份一下之前配置代理的命令</span></span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令</title>
    <url>/2021/08/03/d105761cf6b8.html</url>
    <content><![CDATA[<ol>
<li>新建feature分支  git checkout -b feature_x  checkout 切换  -b feature_x branch feature_x 新建分支x</li>
<li>查看分支 git branch</li>
<li>删除本地分支 git branch -d feature_x</li>
<li>删除远程分支 git push origin –delete feature_x</li>
<li>git rebase master -&gt; git rebase –contionue</li>
<li>纳入版本控制 git add xxx.xx</li>
<li>git pull 拉代码</li>
<li>git push 推代码</li>
<li>git cherry-pick <commitHash> 将指定的提交（commit）应用于其他分支。</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/14/e02fd06e5bfc.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="jnimg"><a href="#jnimg" class="headerlink" title="jnimg"></a>jnimg</h3><p>demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% qnimg test/demo.jpg title:图片标题 alt:图片说明 &#x27;class:class1 class2&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% qnimg imageFile attr1:value1 attr2:value2 &#x27;attr3:value31 value32 value3n&#x27; [extend:?imageView2/2/w/600 | normal:yes] %&#125;</span><br><span class="line">&#123;% qnjs jsFile attr1:value1 attr2:value2 &#x27;attr3:value31 value32 value3n&#x27; %&#125;</span><br><span class="line">&#123;% qncss cssFile attr1:value1 attr2:value2 &#x27;attr3:value31 value32 value3n&#x27; %&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<img title="图片标题" alt="图片说明" class="class1 class2 lazyload" src="https://cdn.songsong.ink/blog/images/demo.jpg?imageView2/2/w/600" class="lazyload" data-srcset="https://cdn.songsong.ink/blog/images/demo.jpg?imageView2/2/w/600" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=">

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>


<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>idea常用快捷键总结</title>
    <url>/2021/08/02/5046cc886a09.html</url>
    <content><![CDATA[<ol>
<li>ctrl+shift+(+/-)展开全部折叠全部</li>
<li>ctrl+（+/-） 展开折叠当前方法</li>
<li>ctrl+shift+U 全部转换为大写or小写</li>
<li>ctrl+H 查看类继承关系，不能看实现接口</li>
<li>ctrl + alt + u 既能看继承关系也能看接口</li>
</ol>
]]></content>
      <categories>
        <category>idea</category>
      </categories>
  </entry>
  <entry>
    <title>linux create service</title>
    <url>/2021/08/05/9877030524ce.html</url>
    <content><![CDATA[<p>linux服务配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 创建服务文件 </span></span><br><span class="line">vim /etc/systemd/system/EmbyMedia_GoogleMovie_play.service</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Rclone</span><br><span class="line">AssertPathIsDirectory=/mnt/googledrive</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/rclone mount googledrive:movies /mnt/googledrive   --umask 0000  --default-permissions  --allow-non-empty  --allow-other  --buffer-size 32M  --dir-cache-time 12h --vfs-cache-mode writes --vfs-read-chunk-size 64M  --vfs-read-chunk-size-limit 1G</span><br><span class="line">ExecStop=/bin/fusermount -u /mnt/googledrive   </span><br><span class="line">Restart=on-abort</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#重载daemon，让新的服务文件生效</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">#启动rclone</span><br><span class="line">systemctl start EmbyMedia_VIP_Movie_play EmbyMedia_VIP_TVasia_play EmbyMedia_VIP_TVnf_play</span><br><span class="line">#设置开机启动：</span><br><span class="line">systemctl</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux hash commond</title>
    <url>/2021/12/14/af17eafac893.html</url>
    <content><![CDATA[<h2 id="1-linux系统下的hash指令"><a href="#1-linux系统下的hash指令" class="headerlink" title="1.linux系统下的hash指令"></a>1.linux系统下的hash指令</h2><p>说明：<br>linux系统下会有一个hash表，当你刚开机时这个hash表为空，每当你执行过一条命令时，hash表会记录下这条命令的路径，就相当于缓存一样。第一次执行命令shell解释器默认的会从PATH路径下寻找该命令的路径，当你第二次使用该命令时，shell解释器首先会查看hash表，没有该命令才会去PATH路径下寻找。<br>hash表的作用：<br>大大提高命令的调用速率。</p>
<h2 id="2-hash命令参数"><a href="#2-hash命令参数" class="headerlink" title="2 hash命令参数"></a>2 hash命令参数</h2><p>-l  显示hash表内容</p>
<p>-r 清除hash表</p>
<p>-d openssl 删除表中某一条（删除openssl）</p>
<p>-t openssl 查看openssl命令路径（hash表中没有的话，可以调用which命令）</p>
<p>-p /usr/bin/openssl aliesopenssl 往hash表中添加一条，执行aliesopenssl即执行openssl命令（起别名）</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>判断环境中是否存在某命令</p>
<p>check_program_installed() {<br>    hash $1 &gt; /dev/null 2&gt;&amp;1<br>    if [ “$?” != “0” ]; then<br>    print “command $1 not found. is it installed?.”<br>    exit 1<br>    fi<br>}</p>
<h3 id="查看服务的启动日志"><a href="#查看服务的启动日志" class="headerlink" title="查看服务的启动日志"></a>查看服务的启动日志</h3><p>journalctl -u minio.service</p>
<h3 id="ubuntu-启动bbr"><a href="#ubuntu-启动bbr" class="headerlink" title="ubuntu 启动bbr"></a>ubuntu 启动bbr</h3><p>echo net.core.default_qdisc=fq &gt;&gt; /etc/sysctl.conf<br>echo net.ipv4.tcp_congestion_control=bbr &gt;&gt; /etc/sysctl.conf</p>
<p>sysctl -p</p>
<p>sysctl net.ipv4.tcp_available_congestion_control</p>
<p>就开启了。 执行 lsmod | grep bbr ，以检测 BBR 是否开启。</p>
]]></content>
      <categories>
        <category>linux-commond</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>commond-line</tag>
      </tags>
  </entry>
  <entry>
    <title>linux命令</title>
    <url>/2021/08/05/1982596e3a33.html</url>
    <content><![CDATA[<p>查看端口被那个进程占用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -lnp|grep 7000 </span><br><span class="line">lsof -i :22</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux挂载硬盘</title>
    <url>/2021/11/02/7a593bbc05f0.html</url>
    <content><![CDATA[<h2 id="硬盘情况"><a href="#硬盘情况" class="headerlink" title="硬盘情况"></a>硬盘情况</h2><p>硬盘为无分区表的空白硬盘</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>fdisk -l 查看所有硬盘信息找到要挂载的硬盘（我要挂载的是/dev/sdb）</li>
<li>fdisk /dev/sdb  输入g 常见GPT分区表  在输入n创建分区</li>
<li>mke2fs  -t ext4 /dev/sdb1 将该分区的文件系统设置为ext4</li>
<li>parted -l 查看分区的文件系统确认设置成功</li>
<li>修改 /etc/fstab 添加要挂载的设备 和挂载点</li>
<li>mount -a 让上一步的修改立即生效</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>linux端口号</title>
    <url>/2021/08/20/c4bf1f45066d.html</url>
    <content><![CDATA[<h2 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h2><p>lsof -i:端口号</p>
<h2 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h2><p>netstat -nltp | grep 端口号</p>
<ol>
<li>-a：显示本机所有连接和监听地端口</li>
<li>-n：网络IP地址的形式，显示当前建立的有效连接和端口</li>
<li>-r：显示路由表信息</li>
<li>-s：显示按协议的统计信息</li>
<li>-v：显示当前有效的连接</li>
<li>-t：显示所有TCP协议连接情况</li>
<li>-u：显示所有UDP协议连接情况</li>
<li>-i：显示自动配置端口的状态</li>
<li>-l：仅仅显示连接状态为listening的服务网络状态</li>
<li>-p：显示pid/program name</li>
</ol>
<h2 id="TCP连接的几种状态"><a href="#TCP连接的几种状态" class="headerlink" title="TCP连接的几种状态"></a>TCP连接的几种状态</h2><ol>
<li>ESTABLISHED    已建立 </li>
<li>CLOSED   已关闭 </li>
<li>LISTENING  正在监听</li>
<li>FIN-WAIT-2   等待连接关闭</li>
<li>TIME-WAIT   等待足够时间，确保服务器正常关闭该连接</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>msyql事务隔离级别与锁机制</title>
    <url>/2021/07/20/a064a04de36f.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们的数据库一般都会并发执行多个事务，多个事务可能会并发的对相同的一批数据进行增删改查操作，可能就会导致我们说的脏写、脏读、不可重复读、幻读这些问题。<br>这些问题的本质都是数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了事务隔离机制、锁机制、MVCC多版本并发控制隔离机制，用一整套机制来解决多事务并发问题。接下来，我们会深入讲解这些机制，让大家彻底理解数据库内部的执行原理。</p>
<h2 id="事务及其ACID属性"><a href="#事务及其ACID属性" class="headerlink" title="事务及其ACID属性"></a>事务及其ACID属性</h2><p>事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。</p>
<ol>
<li>原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。</li>
<li>一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性。</li>
<li>隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。</li>
<li>持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。</li>
</ol>
<h2 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h2><h3 id="1-更新丢失-Lost-Update-或脏写"><a href="#1-更新丢失-Lost-Update-或脏写" class="headerlink" title="1. 更新丢失(Lost Update)或脏写"></a>1. 更新丢失(Lost Update)或脏写</h3><p>　　当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p>
<h3 id="2-脏读（Dirty-Reads）"><a href="#2-脏读（Dirty-Reads）" class="headerlink" title="2. 脏读（Dirty Reads）"></a>2. 脏读（Dirty Reads）</h3><p>　　一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。<br>　　一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p>
<h3 id="3-不可重读（Non-Repeatable-Reads）"><a href="#3-不可重读（Non-Repeatable-Reads）" class="headerlink" title="3. 不可重读（Non-Repeatable Reads）"></a>3. 不可重读（Non-Repeatable Reads）</h3><p>　　一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。<br>　　一句话：事务A内部的相同查询语句在不同时刻读出的结果不一致，不符合隔离性</p>
<h3 id="4-幻读（Phantom-Reads）"><a href="#4-幻读（Phantom-Reads）" class="headerlink" title="4. 幻读（Phantom Reads）"></a>4. 幻读（Phantom Reads）</h3><p>　　一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。<br>　　一句话：事务A读取到了事务B提交的新增数据，不符合隔离性</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>“脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p>
<p>数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。<br>同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读”和“幻读”并不敏感,可能更关心数据并发访问的能力。<br>常看当前数据库的事务隔离级别: show variables like ‘tx_isolation’;<br>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;<br>Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别</p>
<h2 id="锁详解"><a href="#锁详解" class="headerlink" title="锁详解"></a>锁详解</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。<br>在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p>
<h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><ol>
<li>从性能上分为乐观锁(用版本对比来实现)和悲观锁</li>
<li>从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁)</li>
<li>读锁（共享锁，S锁(Shared)）：针对同一份数据，多个读操作可以同时进行而不会互相影响</li>
<li>写锁（排它锁，X锁(eXclusive)）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
<li>从对数据操作的粒度分，分为表锁和行锁</li>
</ol>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；一般用在整表数据迁移的场景。行锁实际上是对主键索引加锁开销大<br>基本操作    </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--建表SQL</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `mylock` (</span><br><span class="line">	`id` <span class="type">INT</span> (<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`NAME` <span class="type">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> MyISAM <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">--插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`test`.`mylock` (`id`, `NAME`) <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`test`.`mylock` (`id`, `NAME`) <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`test`.`mylock` (`id`, `NAME`) <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>`test`.`mylock` (`id`, `NAME`) <span class="keyword">VALUES</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>手动增加表锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lock <span class="keyword">table</span> 表名称 read(write),表名称<span class="number">2</span> read(write);</span><br></pre></td></tr></table></figure>

<p>查看表上加过的锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br></pre></td></tr></table></figure>

<p>删除表锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<p>案例分析(加读锁）</p>
<p>当前session和其他session都可以读该表<br>当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待</p>
<p>案例分析(加写锁）</p>
<p>当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞</p>
<p>案例结论<br>1、对MyISAM表的读操作(加读锁) ,不会阻塞其他进程对同一表的读请求,但会阻塞对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。<br>2、对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。<br>InnoDB与MYISAM的最大不同有两点：<br>InnoDB支持事务（TRANSACTION）<br>InnoDB支持行级锁</p>
<p>行锁演示<br>一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞</p>
<p>总结：<br>MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁,在执行update、insert、delete操作会自动给涉及的表加写锁。<br>InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。<br>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</p>
<h2 id="行锁与事务隔离级别案例分析"><a href="#行锁与事务隔离级别案例分析" class="headerlink" title="行锁与事务隔离级别案例分析"></a>行锁与事务隔离级别案例分析</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `balance` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test`.`account` (`name`, `balance`) <span class="keyword">VALUES</span> (<span class="string">&#x27;lilei&#x27;</span>, <span class="string">&#x27;450&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test`.`account` (`name`, `balance`) <span class="keyword">VALUES</span> (<span class="string">&#x27;hanmei&#x27;</span>, <span class="string">&#x27;16000&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test`.`account` (`name`, `balance`) <span class="keyword">VALUES</span> (<span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;2400&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="读未提交："><a href="#读未提交：" class="headerlink" title="读未提交："></a>读未提交：</h3><p>（1）打开一个客户端A，并设置当前事务模式为read uncommitted（未提交读），查询表account的初始值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># MySQL8查询事务应该使用transaction_isolation，tx_isolation在MySQL <span class="number">5.7</span><span class="number">.20</span>后被弃用。</span><br><span class="line"><span class="keyword">set</span> tx_isolation<span class="operator">=</span><span class="string">&#x27;read-uncommitted&#x27;</span>;</span><br><span class="line"><span class="comment">-- 8.0</span></span><br><span class="line"><span class="keyword">set</span> transaction_isolation<span class="operator">=</span><span class="string">&#x27;read-uncommitted&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>
<p> <br>（3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据： </p>
<p>　　　　<br>（4）一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据： </p>
<p> 　　　　<br>（5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别</p>
<p> </p>
<h3 id="3、读已提交"><a href="#3、读已提交" class="headerlink" title="3、读已提交"></a>3、读已提交</h3><p>（1）打开一个客户端A，并设置当前事务模式为read committed（未提交读），查询表account的所有记录：<br>set tx_isolation=’read-committed’;</p>
<p>　　　　<br>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account： </p>
<p>　　　　<br>（3）这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题： </p>
<p>　　　　<br>（4）客户端B的事务提交</p>
<p>　　　　<br>（5）客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p>
<p> </p>
<h3 id="4、可重复读"><a href="#4、可重复读" class="headerlink" title="4、可重复读"></a>4、可重复读</h3><p>（1）打开一个客户端A，并设置当前事务模式为repeatable read，查询表account的所有记录<br>set tx_isolation=’repeatable-read’;</p>
<p>　　　　<br>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</p>
<p>　　　　<br>（3）在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题</p>
<p>　　　　<br>（4）在客户端A，接着执行update account set balance = balance - 50 where id = 1，balance没有变成400-50=350，lilei的balance值用的是步骤2中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了MVCC(multi-version concurrency control)机制，select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本号，是当前读（当前版本）。</p>
<p>（5）重新打开客户端B，插入一条新数据后提交</p>
<p>（6）在客户端A查询表account的所有记录，没有查出新增数据，所以没有出现幻读</p>
<p>（7)验证幻读<br>在客户端A执行update account set balance=888 where id = 4;能更新成功，再次查询能查到客户端B新增的数据</p>
<h3 id="5、串行化"><a href="#5、串行化" class="headerlink" title="5、串行化"></a>5、串行化</h3><p>（1）打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值：<br>set tx_isolation=’serializable’;</p>
<p>（2）打开一个客户端B，并设置当前事务模式为serializable，更新相同的id为1的记录会被阻塞等待，更新id为2的记录可以成功，说明在串行模式下innodb的查询也会被加上行锁。<br>如果客户端A执行的是一个范围查询，那么该范围内的所有行包括每行记录所在的间隙区间范围(就算该行数据还未被插入也会加锁，这种是间隙锁)都会被加锁。此时如果客户端B在该范围内插入数据都会被阻塞，所以就避免了幻读。<br>这种隔离级别并发性极低，开发中很少会用到。  </p>
<h2 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁(Gap Lock)"></a>间隙锁(Gap Lock)</h2><p>间隙锁，锁的就是两个值之间的空隙。Mysql默认级别是repeatable-read，有办法解决幻读问题吗？间隙锁在某些情况下可以解决幻读问题。<br>假设account表里数据如下：</p>
<p>那么间隙就有 id 为 (3,10)，(10,20)，(20,正无穷) 这三个区间，<br>在Session_1下面执行 update account set name = ‘zhuge’ where id &gt; 8 and id &lt;18;，则其他Session没法在这个范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙里插入或修改任何数据，即id在(3,20]区间都无法修改数据，注意最后那个20也是包含在内的。<br>间隙锁是在可重复读隔离级别下才会生效。</p>
<h2 id="临键锁-Next-key-Locks"><a href="#临键锁-Next-key-Locks" class="headerlink" title="临键锁(Next-key Locks)"></a>临键锁(Next-key Locks)</h2><p>Next-Key Locks是行锁与间隙锁的组合。像上面那个例子里的这个(3,20]的整个区间可以叫做临键锁。</p>
<p>无索引行锁会升级为表锁(RR级别会升级为表锁，RC级别不会升级为表锁)<br>锁主要是加在索引上，如果对非索引字段更新，行锁可能会变表锁<br>session1 执行：update account set balance = 800 where name = ‘lilei’;<br>session2 对该表任一行操作都会阻塞住<br>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。</p>
<p>锁定某一行还可以用lock in share mode(共享锁) 和for update(排它锁)，例如：select * from test_innodb_lock where a = 2 for update; 这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体并发处理能力方面要远远优于MYISAM的表级锁定的。当系统并发量高的时候，Innodb的整体性能和MYISAM相比就会有比较明显的优势了。<br>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MYISAM高，甚至可能会更差。</p>
<h2 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h2><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况<br>show status like ‘innodb_row_lock%’;</p>
<p>对各个状态量的说明如下：<br>Innodb_row_lock_current_waits: 当前正在等待锁定的数量<br>Innodb_row_lock_time: 从系统启动到现在锁定总时间长度<br>Innodb_row_lock_time_avg: 每次等待所花平均时间<br>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间<br>Innodb_row_lock_waits: 系统启动后到现在总共等待的次数</p>
<p>对于这5个状态变量，比较重要的主要是：<br>Innodb_row_lock_time_avg （等待平均时长）<br>Innodb_row_lock_waits （等待总次数）<br>Innodb_row_lock_time（等待总时长）</p>
<p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p>
<p>查看INFORMATION_SCHEMA系统库锁相关数据表<br>– 查看事务<br>select * from INFORMATION_SCHEMA.INNODB_TRX;<br>– 查看锁<br>select * from INFORMATION_SCHEMA.INNODB_LOCKS;<br>– 查看锁等待<br>select * from INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</p>
<p>– 释放锁，trx_mysql_thread_id可以从INNODB_TRX表里查看到<br>kill trx_mysql_thread_id</p>
<p>– 查看锁等待详细信息<br>show engine innodb status\G; </p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>set tx_isolation=’repeatable-read’;<br>Session_1执行：select * from account where id=1 for update;<br>Session_2执行：select * from account where id=2 for update;<br>Session_1执行：select * from account where id=2 for update;<br>Session_2执行：select * from account where id=1 for update;<br>查看近期死锁日志信息：show engine innodb status\G;<br>大多数情况mysql可以自动检测死锁并回滚产生死锁的那个事务，但是有些情况mysql没法自动检测死锁</p>
<h2 id="锁优化建议"><a href="#锁优化建议" class="headerlink" title="锁优化建议"></a>锁优化建议</h2><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁<br>合理设计索引，尽量缩小锁的范围<br>尽可能减少检索条件范围，避免间隙锁<br>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行<br>尽可能低级别事务隔离</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql索引</title>
    <url>/2021/07/15/d148b73a7a10.html</url>
    <content><![CDATA[<h2 id="mysql索引"><a href="#mysql索引" class="headerlink" title="mysql索引"></a>mysql索引</h2><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><p>索引是帮助Mysql高效获取数据的排好序的数据结构。</p>
<p>索引可以用的数据结构有：</p>
<ul>
<li>二叉树</li>
<li>红黑树</li>
<li>Hash表</li>
<li>B-Tree</li>
</ul>
<h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><ul>
<li><p>叶子节点具有相同的深度，叶节点的指针为空</p>
</li>
<li><p>所有索引元素不重复</p>
</li>
<li><p>节点中的数据索引从左往右递增排列</p>
<h3 id="B-树（B树变种）"><a href="#B-树（B树变种）" class="headerlink" title="B+树（B树变种）"></a>B+树（B树变种）</h3></li>
<li><p>非叶子节点不存储data，只存储索引（索引会冗余），因此每页可以存储更多索引</p>
</li>
<li><p>叶子节点包含所有索引字段</p>
</li>
<li><p>叶子节点用指针连接，提高区间访问能力</p>
</li>
</ul>
<h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>索引文件和数据文件在一起的是聚集索引。</p>
<h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>索引文件和数据文件分离的是非聚集索引</p>
<h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>InnoDb索引是聚集索引。表数据本身就是按照B+树结构存储的一个索引结构文件。因此InnDB存储的表必须存在主键。<br>辅助索引使用的非聚集索引。存储的是主键值。聚集索引的叶子节点包含了完整的数据记录。</p>
<h4 id="为何InonoDB非主键索引结构叶子节点存储的是主键值"><a href="#为何InonoDB非主键索引结构叶子节点存储的是主键值" class="headerlink" title="为何InonoDB非主键索引结构叶子节点存储的是主键值"></a>为何InonoDB非主键索引结构叶子节点存储的是主键值</h4><p>非主键索引叶子节点存储主键而不是存储数据是从两方面考虑。一是如果存储数据数据的更新删除添加操作会存在数据不一致问题。<br>维护数据一致性会很复杂。二是会浪费大量空间。</p>
<h4 id="为什么InnoDb表必须有主键且推荐使用整型的自增主键"><a href="#为什么InnoDb表必须有主键且推荐使用整型的自增主键" class="headerlink" title="为什么InnoDb表必须有主键且推荐使用整型的自增主键"></a>为什么InnoDb表必须有主键且推荐使用整型的自增主键</h4><p>表数据本身就是按照B+树结构存储的，因此必须有主键，</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引的存储结构也是采用b+树，索引值是按照构建索引时键的顺序存储。<br>叶子节点存储的是主键值。</p>
<h4 id="最左前缀原理"><a href="#最左前缀原理" class="headerlink" title="最左前缀原理"></a>最左前缀原理</h4><p>如果要使用联合索引必须要遵循最左前缀原理使用。比如key（a,b,c）<br>直接使用c是几乎不会走索引的。也就是说要使用联合索引的字段进行查询。<br>在联合索引中这个字段的左侧字段也必须使用。不然不会走索引（覆盖索引例外）。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>索引</tag>
        <tag>数据结构</tag>
        <tag>B+树</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql缓冲池</title>
    <url>/2021/07/20/3b09f9fb9d8b.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>缓冲池</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2021/09/18/a3e5f334146b.html</url>
    <content><![CDATA[<h1 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h1><h2 id="1-轮循均衡（Round-Robin）"><a href="#1-轮循均衡（Round-Robin）" class="headerlink" title="1. 轮循均衡（Round Robin）"></a>1. 轮循均衡（Round Robin）</h2><p>每一次来自网络的请求轮流分配给内部中的服务器，从 1 至N然后重新开始。此种均衡算法适合 于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p>
<h2 id="2-权重轮循均衡（Weighted-Round-Robin）"><a href="#2-权重轮循均衡（Weighted-Round-Robin）" class="headerlink" title="2. 权重轮循均衡（Weighted Round Robin）"></a>2. 权重轮循均衡（Weighted Round Robin）</h2><p>根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请 求。例如：服务器A的权值被设计成 1，B 的权值是 3，C的权值是 6，则服务器A、B、C将分 别接受到10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用 率，避免低性能的服务器负载过重。</p>
<h2 id="3-随机均衡（Random）"><a href="#3-随机均衡（Random）" class="headerlink" title="3. 随机均衡（Random）"></a>3. 随机均衡（Random）</h2><p>把来自网络的请求随机分配给内部中的多个服务器。 </p>
<h2 id="4-权重随机均衡（Weighted-Random）"><a href="#4-权重随机均衡（Weighted-Random）" class="headerlink" title="4. 权重随机均衡（Weighted Random）"></a>4. 权重随机均衡（Weighted Random）</h2><p>此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。 </p>
<h2 id="5-响应速度均衡（Response-Time-探测时间）"><a href="#5-响应速度均衡（Response-Time-探测时间）" class="headerlink" title="5. 响应速度均衡（Response Time 探测时间）"></a>5. 响应速度均衡（Response Time 探测时间）</h2><p>负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测 请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映 服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时<br>间，而不是客户端与服务器间的最快响应时间</p>
<h2 id="6-最少连接数均衡（Least-Connection）"><a href="#6-最少连接数均衡（Least-Connection）" class="headerlink" title="6. 最少连接数均衡（Least Connection）"></a>6. 最少连接数均衡（Least Connection）</h2><p>  最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在 处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡 更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如 FTP。</p>
<h2 id="7-处理能力均衡（CPU、内存）"><a href="#7-处理能力均衡（CPU、内存）" class="headerlink" title="7. 处理能力均衡（CPU、内存）"></a>7. 处理能力均衡（CPU、内存）</h2><p>此种均衡算法将把服务请求分配给内部中处理负荷（根据服务器CPU型号、CPU数量、内存大小 及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行 状况，所以此种均衡算法相对来说更加精确，尤其适合运用到第七层（应用层）负载均衡的情况 下。</p>
<h2 id="8-DNS响应均衡（Flash-DNS）"><a href="#8-DNS响应均衡（Flash-DNS）" class="headerlink" title="8. DNS响应均衡（Flash DNS）"></a>8. DNS响应均衡（Flash DNS）</h2><p>在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在 同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端，则客户端将以最先收到 的域名解析 IP 地址来继续请求服务，而忽略其它的 IP 地址响应。在种均衡策略适合应用在全局负 载均衡的情况下，对本地负载均衡是没有意义的。</p>
<h2 id="9-哈希算法"><a href="#9-哈希算法" class="headerlink" title="9. 哈希算法"></a>9. 哈希算法</h2><p>一致性哈希一致性Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往 该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>
<h2 id="10-IP-地址散列（保证客户端服务器对应关系稳定）"><a href="#10-IP-地址散列（保证客户端服务器对应关系稳定）" class="headerlink" title="10. IP 地址散列（保证客户端服务器对应关系稳定）"></a>10. IP 地址散列（保证客户端服务器对应关系稳定）</h2><p>通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分 组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信 时，该算法能够以流(会话)为单位，保证来自相同客户端的通信能够一直在同一服务器中进行处 理。</p>
<h2 id="11-URL-散列"><a href="#11-URL-散列" class="headerlink" title="11. URL 散列"></a>11. URL 散列</h2><p>通过管理客户端请求URL 信息的散列，将发送至相同URL 的请求转发至同一服务器的算法。</p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>开放Oracle cloud 实例的端口</title>
    <url>/2021/12/21/35adf57486dd.html</url>
    <content><![CDATA[<h1 id="甲骨文实例开放端口"><a href="#甲骨文实例开放端口" class="headerlink" title="甲骨文实例开放端口"></a>甲骨文实例开放端口</h1><ol>
<li>控制台开放安全组</li>
<li>ubuntu系统默认使用了 iptables防火墙<h1 id="iptables-防火墙开放端口"><a href="#iptables-防火墙开放端口" class="headerlink" title="iptables 防火墙开放端口"></a>iptables 防火墙开放端口</h1></li>
</ol>
<p>iptables -I INPUT -p tcp –dport 80 -j ACCEPT</p>
]]></content>
      <categories>
        <category>vps</category>
      </categories>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>paper1</title>
    <url>/2021/12/23/a7c12a6841a6.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e8a12e4b28052de7420ee9cde29098d636654483846e14359b64b4c1e158b84b">785042224d1447b638210094ce7e79710e5e45f1824a4082c60a173d0c5f7ec8e8cea4f52873b75849cc5a5398bb2bd98e816c63eed5d93abd890620b4e2d7988d17465834a28149af4b83a99336c153b9954d19368c292949fd6f757b152565a4f186abe2da324a56ce1ea75ba57e291ed504b57ee4e28a9052d08c338afe4543938d289d709dab1633c4ad837ab7f98a6bfa120b2feebb29dd59a93f7c2ce37ec0476986ae62505432e8c72436b2475eb00aa3e1e35b461b9d4aba1b145654f89fa91b0d063b195376380f83b598c415098ae7457385e14deafd51b7a4a145895574c0790ad312dbd12e3e9e63560f166f9d31d52cd1524d98dd7e5412b472cba3ce3aaaeabc0ca32ab76e998cda3ea6f0fe92f5842c453c7ff184d33ed63ca31900e12cc98a7e22979f4ce1a26718e6adfec34c1460771c59fb5ca1498a2ee6795eff6b3b4b8342041ad27313a6703a93551d79d610c0e4dc4acaa7c3f71c8143f354ac674037d54664b4f311390ecee37e0c119dc31641f8893072d4a1d72ae85d4984210cef1a2bc392aba358121bc52374c5ad2039330e1b2f09c70f5e72e3fe97b0eabb4fb444481bc70f10b9b3ca5a73be24a3d3e3b3455839c234470812cb9373e0b294ffe69964916da0c9c76e00cbd1456440baf5e18b1e8a7c550390476cd36c425f6311581e91260d07b0c7b48b6c0d60631129a8f5f2c3ab02399a13aec4b9b0a98a41bb26326ef1c3e59f86f1e73aa3b225153b0c5adf88380f799b3c47613f453e7f2ace081ff0f48c3e9e5ffa71fff14b1687645279e6e6369cfc8b578a5bc01960675f640be1a707af8cb4afa90f0849e8a67b3f08cd07395dca6b0a3c6a71847d9ae3e4e195412158731dfe3476499ce7ca8bd06144ec997b9079a7edf175cd80e6b8942b14a9f7c3407e8c20eeac8030aaba865ebbbfef1c7e30e65df5b07e315faee5aa9f61b84b66f8edae4f40c89ff6411409d537cc8a51c6cac6773a7ac20fd6bcdc808f93c85917207c97440c579f95581f1bf1f557e8da3d91d3eb274fafd053493935ae211b469d9e772d61ecbc9adf404467bb5fc19c67e4bac27e1124eab22374cc1cab71511195e1e30257ab84f7d910d06a430d1fdee692b659a46c550aa96f32c2d210deed0612aeab888103d41fb9ff6c92bea1a3f5c2ddb2b9b8a0c7ee7f75210b0126132d88e57c8642728e406e0fa38c3275d70bb0a4b64bf08517414ddb3d4afee6d301cb276502ce6bd6b0496ee7024cfbab6f4f4b36dd674c9ebcac493c8dd78ac6c6f8890bbf5775dfe0aee2b96d808a932851bf126697f181f7695450ecebcd2fd5e481ebf082f71c26faac3a3f400a85d66b11e6bdb9f1d3d7b633400c9a46a9731eff97a527c2e221968da3968807be10470fac2bf1c0b0bd69b78959198833b2b95235e707a5bd9a79abebccdcc5935425c5ccdcce5af34850e3cc30b64c6e76cb3b73cb3d9c28db83d8be215b72b2cd57e915c2c03392e928dffb24d5c7a3d54be184ac510a71475f969ae6f429ff2691b8b08caa5e8d6126ac</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里有东西被加密了，需要输入密码查看。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>rabbitmq记录</title>
    <url>/2021/10/02/8b32a579046d.html</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 添加用户</span></span><br><span class="line">rabbitmqctl add_user admin 111111</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p / admin <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
  </entry>
  <entry>
    <title>redis常用操作哦</title>
    <url>/2021/08/23/5ed71c7fdf57.html</url>
    <content><![CDATA[<h1 id="1-redis的五种数据结构"><a href="#1-redis的五种数据结构" class="headerlink" title="1.redis的五种数据结构"></a>1.redis的五种数据结构</h1><ol>
<li>字符串String</li>
<li>哈希表hash</li>
<li>列表list</li>
<li>集合set</li>
<li>有序集合zset</li>
</ol>
<h2 id="1-1字符串的常用操作"><a href="#1-1字符串的常用操作" class="headerlink" title="1.1字符串的常用操作"></a>1.1字符串的常用操作</h2><ol>
<li>set key value  存储一个键值对</li>
<li>mset key value key value … 存储多个键值对</li>
<li>setnx key value 存储一个不存在的键值对</li>
<li>get key 获取一个value</li>
<li>mget key … 批量获取key的value</li>
<li>del key … 批量删除键值对</li>
<li>expire key seconds 设置过期时间</li>
<li>incr key key的整数值加1</li>
<li>decr key key的整数值减1</li>
<li>incrby key increment key的值加increment</li>
<li>decrby key decrement key的值减去decrement</li>
</ol>
<p>规范化自己的代码风格，使用缓存优化效率，在高并发情况下的边界问题问题处理。学习优秀的开源项目源码，并且加上自己的实现完成自己的开发。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>spingboot配置</title>
    <url>/2021/08/02/5c1a3fdb1604.html</url>
    <content><![CDATA[<h2 id="使用profile切换配置环境"><a href="#使用profile切换配置环境" class="headerlink" title="使用profile切换配置环境"></a>使用profile切换配置环境</h2><p>spring boot允许你通过命名约定按照一定的格式(application-{profile}.properties)来定义多个配置文件，然后通过在application.properyies通过spring.profiles.active来具体激活一个或者多个配置文件，如果没有没有指定任何profile的配置文件的话，spring boot默认会启动application-default.properties。</p>
<h3 id="vm参数配置-Dspring-profiles-active"><a href="#vm参数配置-Dspring-profiles-active" class="headerlink" title="vm参数配置 -Dspring.profiles.active"></a>vm参数配置 -Dspring.profiles.active</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groovyScript(&quot;def result=&#x27;&#x27;; </span><br><span class="line">def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&#x27;[\\\\[|\\\\]|\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); </span><br><span class="line">result+= params.size()  += &#x27;\\n&#x27;; </span><br><span class="line">for(i = 0; i &lt; params.size(); i++) &#123;</span><br><span class="line">	if(params[i] == &#x27;&#x27;) </span><br><span class="line">		return result;</span><br><span class="line">	if(i==0) </span><br><span class="line">		result += &#x27;\\n&#x27;; </span><br><span class="line">	result+=&#x27; * @param &#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\n&#x27; : &#x27;&#x27;)</span><br><span class="line">	&#125;; </span><br><span class="line">return result&quot;, </span><br><span class="line">methodParameters()) </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>springboot</category>
      </categories>
  </entry>
  <entry>
    <title>spring源码阅读</title>
    <url>/2022/02/07/d91a37f31693.html</url>
    <content><![CDATA[<h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><p>1 类怎么注入到容器中成为一个Bean?<br>类注入到容器中需要三步 1 配置类 2 加载上下文 3 getbean<br>2 配置类的三种形式  通过xml 注解 javaconfig<br>b. 加载spring上下文<br>xml： new ClassPathXmlApplicationCOntext(“xml”)<br>注解: new AnnotationConfigApplication(config.class)</p>
<p>xml方式和注解形式的上下文都是读取后成为BeanDefine</p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2>]]></content>
  </entry>
  <entry>
    <title>spring面试</title>
    <url>/2021/09/09/a1a07dd22c32.html</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu修改hostname</title>
    <url>/2021/08/20/3f9300d23ecc.html</url>
    <content><![CDATA[<h2 id="修改-etc-cloud-cloud-cfg文件"><a href="#修改-etc-cloud-cloud-cfg文件" class="headerlink" title="修改/etc/cloud/cloud.cfg文件"></a>修改/etc/cloud/cloud.cfg文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">preserve_hostname: <span class="literal">false</span></span><br><span class="line">修改</span><br><span class="line">preserve_hostname: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="执行命令-hostnamectl-set-hostname-主机名"><a href="#执行命令-hostnamectl-set-hostname-主机名" class="headerlink" title="执行命令 hostnamectl set-hostname 主机名"></a>执行命令 hostnamectl set-hostname 主机名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname testname</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu hostname</tag>
      </tags>
  </entry>
  <entry>
    <title>win10打印服务无法启动</title>
    <url>/2021/12/13/666267bebac1.html</url>
    <content><![CDATA[<p>cmd输入 net start spooler。 启动错误 1068依赖服务或组无法启动，<br>cmd中输入以下命令：sc config spooler depend= rpcss   然后再重新启动print spooler服务就可以了。</p>
]]></content>
      <categories>
        <category>win10</category>
      </categories>
      <tags>
        <tag>打印服务</tag>
      </tags>
  </entry>
  <entry>
    <title>一次git误删除本地commit的补救</title>
    <url>/2021/08/14/aae24ddbc03a.html</url>
    <content><![CDATA[<h2 id="事故起因"><a href="#事故起因" class="headerlink" title="事故起因"></a>事故起因</h2><p>为了保证push到远端时commit是干净的，准备对本地的commit进行合并，此时处于马上要下班的兴奋时刻，手一哆嗦把误点了drop。准备提交的所有commit消失不见</p>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><ol>
<li>git status</li>
<li>git reflog  –date=iso 查看git的记录找到当时的commit</li>
<li>git checkout -b tmp a823ba6 ## a823ba6为删除的最后一个commit的id</li>
<li>git log</li>
<li>git branch</li>
<li>git checkout kfapi8-11-19-54</li>
<li>git branch</li>
<li>git branch -m kfapi8-11-19-54-back</li>
<li>git checkout tmp</li>
<li>git branch -m kfapi8-11-19-54</li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>三大范式</title>
    <url>/2021/07/15/6600b3cedb94.html</url>
    <content><![CDATA[<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><h3 id="第一范式（1NF）："><a href="#第一范式（1NF）：" class="headerlink" title="第一范式（1NF）："></a>第一范式（1NF）：</h3><p>要求数据库表的每一列都是不可分割的原子数据项。</p>
<h3 id="第二范式（2NF）："><a href="#第二范式（2NF）：" class="headerlink" title="第二范式（2NF）："></a>第二范式（2NF）：</h3><p>在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</p>
<p>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</p>
<h3 id="第三范式（3NF）："><a href="#第三范式（3NF）：" class="headerlink" title="第三范式（3NF）："></a>第三范式（3NF）：</h3><p>在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</p>
<p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>范式</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手四次挥手</title>
    <url>/2021/07/27/33e37655d720.html</url>
    <content><![CDATA[<h2 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h2><p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”</p>
<p>这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p>
<p>我们先来知道什么是 TCP 连接？</p>
<p>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</p>
<p>所以，重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。</strong></p>
<p>接下来以三个方面分析三次握手的原因：</p>
<ul>
<li>  三次握手才可以阻止重复历史连接的初始化（主要原因）</li>
<li>  三次握手才可以同步双方的初始序列号</li>
<li>  三次握手才可以避免资源浪费</li>
</ul>
<p><em>原因一：避免历史连接</em></p>
<p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p>
<p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？</p>
<img src="https://pic2.zhimg.com/50/v2-ac0ecdad293a096d6b9402231af9f202_hd.jpg?source=1940ef5c" class="lazyload" data-srcset="https://pic2.zhimg.com/50/v2-ac0ecdad293a096d6b9402231af9f202_hd.jpg?source=1940ef5c" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="50%" height="50%">
客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：

<ul>
<li>  一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li>
<li>  那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li>
<li>  客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li>
</ul>
<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p>
<ul>
<li>  如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</li>
<li>  如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</li>
</ul>
<p>所以， TCP 使用三次握手建立连接的最主要原因是<strong>防止历史连接初始化了连接。</strong></p>
<p><em>原因二：同步双方初始序列号</em></p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>  接收方可以去除重复的数据；</li>
<li>  接收方可以根据数据包的序列号按序接收；</li>
<li>  可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-4c7d19df7e5964f1ee7a0a079ac30c51_hd.jpg?source=1940ef5c" class="lazyload" data-srcset="https://pic1.zhimg.com/50/v2-4c7d19df7e5964f1ee7a0a079ac30c51_hd.jpg?source=1940ef5c" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p>
<p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<p><em>原因三：避免资源浪费</em></p>
<p>如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成什么情况呢？</p>
<p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p>
<p><img src="https://pic1.zhimg.com/50/v2-60b3f27b9214aee5ca33ec648ab5ea60_hd.jpg?source=1940ef5c" class="lazyload" data-srcset="https://pic1.zhimg.com/50/v2-60b3f27b9214aee5ca33ec648ab5ea60_hd.jpg?source=1940ef5c" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
<hr>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><blockquote>
<p>TCP 四次挥手过程和状态变迁  </p>
</blockquote>
<p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过<strong>四次挥手</strong>方式。</p>
<p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p>
<p><img src="https://pic1.zhimg.com/50/v2-2085b747725cd09fb01334cd29774b6d_hd.jpg?source=1940ef5c" class="lazyload" data-srcset="https://pic1.zhimg.com/50/v2-2085b747725cd09fb01334cd29774b6d_hd.jpg?source=1940ef5c" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<ul>
<li>  客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>  服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li>
<li>  客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>  等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>  客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>  服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>  客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p>
<p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p>
<blockquote>
<p>为什么挥手需要四次？<br>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p>
</blockquote>
<ul>
<li>  关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>  服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p>
<blockquote>
<p>为什么 TIME_WAIT 等待的时间是 2MSL？  </p>
</blockquote>
<p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p>
<p>其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT </span><br><span class="line">                                    state, about 60 seconds  */</span><br></pre></td></tr></table></figure>

<p>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p>
<blockquote>
<p>为什么需要 TIME_WAIT 状态？  </p>
</blockquote>
<p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p>
<p>需要 TIME-WAIT 状态，主要是两个原因：</p>
<ul>
<li>  防止具有相同「四元组」的「旧」数据包被收到；</li>
<li>  保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li>
</ul>
<p><em>原因一：防止旧连接的数据包</em></p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p>
<p><img src="https://pic1.zhimg.com/50/v2-5e3336e73d8b924381f347d0ebab1b71_hd.jpg?source=1940ef5c" class="lazyload" data-srcset="https://pic1.zhimg.com/50/v2-5e3336e73d8b924381f347d0ebab1b71_hd.jpg?source=1940ef5c" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<ul>
<li>  如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li>
<li>  这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li>
</ul>
<p>所以，TCP 就设计出了这么一个机制，经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><em>原因二：保证连接正确关闭</em></p>
<p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：</p>
<p><em>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</em></p>
<p>也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p>
<p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p>
<p><img src="https://pic4.zhimg.com/50/v2-6a44dd001ef2ece18297121c90305861_hd.jpg?source=1940ef5c" class="lazyload" data-srcset="https://pic4.zhimg.com/50/v2-6a44dd001ef2ece18297121c90305861_hd.jpg?source=1940ef5c" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<ul>
<li>  如上图红色框框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。</li>
<li>  当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</li>
</ul>
<p>如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：</p>
<ul>
<li>  服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</li>
<li>  服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</li>
</ul>
<p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以<strong>保证双方的连接都可以正常的关闭。</strong></p>
<blockquote>
<p>TIME_WAIT 过多有什么危害？  </p>
</blockquote>
<p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。</p>
<p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>  第一是内存资源占用；</li>
<li>  第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</li>
</ul>
<p>第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过如下参数设置指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range</span><br></pre></td></tr></table></figure>

<p><strong>如果发起连接一方的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</strong></p>
<p>客户端受端口资源限制：</p>
<p>客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。</p>
<p>服务端受系统资源限制：</p>
<p>由于一个四元组表示 TCP 连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口 但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多一直不断的连接了。所以当服务端出现大量 TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。</p>
<blockquote>
<p>如何优化 TIME_WAIT？  </p>
</blockquote>
<p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p>
<ul>
<li>  打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>  net.ipv4.tcp_max_tw_buckets</li>
<li>  程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
<p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em></p>
<p>如下的 Linux 内核参数开启后，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p>
<p>有一点需要注意的是，<strong>tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br></pre></td></tr></table></figure>

<p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps=1（默认即为 1）</span><br></pre></td></tr></table></figure>

<p>这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。</p>
<p>由于引入了时间戳，我们在前面提到的 <code>2MSL</code> 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>
<p><em>方式二：net.ipv4.tcp_max_tw_buckets</em></p>
<p>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接<strong>一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。</strong></p>
<p>这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</p>
<p><em>方式三：程序中使用 SO_LINGER</em></p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct linger so_linger;</span><br><span class="line">so_linger.l_onoff = 1;</span><br><span class="line">so_linger.l_linger = 0;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));</span><br></pre></td></tr></table></figure>

<p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p>
<p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>企业微信客服接入</title>
    <url>/2021/07/29/05a78b7aff72.html</url>
    <content><![CDATA[<h1 id="微信客服可实现的功能"><a href="#微信客服可实现的功能" class="headerlink" title="微信客服可实现的功能"></a>微信客服可实现的功能</h1><ul>
<li>可将企业员工配置为微信客服的接待人员，在企业微信里接收和回复用户在微信内、外发起的咨询消息</li>
<li>可在企业微信里通过API来管理微信客服帐号、分配客服会话和收发客服消息等。</li>
<li>可使用客服工具栏、「升级服务」等工具</li>
</ul>
<h1 id="微信客服的接入场景"><a href="#微信客服的接入场景" class="headerlink" title="微信客服的接入场景"></a>微信客服的接入场景</h1><h2 id="1、在微信内接入"><a href="#1、在微信内接入" class="headerlink" title="1、在微信内接入"></a>1、在微信内接入</h2><ul>
<li>在视频号中接入：企业在企业微信管理后台的“微信客服应用-在视频号中接入”处，选择企业已绑定的视频号，并选择在该视频号中接入的微信客服即可。</li>
<li>在微信内网页接入</li>
<li>在公众号中接入</li>
<li>在小程序中接入 | 小程序API</li>
<li>在搜一搜品牌官方区中接入</li>
<li>在微信支付凭证处接入<h2 id="2、在微信外接入"><a href="#2、在微信外接入" class="headerlink" title="2、在微信外接入"></a>2、在微信外接入</h2></li>
<li>在App中接入 | SDK</li>
<li>在微信外网页接入<h2 id="开启api"><a href="#开启api" class="headerlink" title="开启api"></a>开启api</h2></li>
</ul>
<p>开启API之后，微信联系人与企业接待人员的所有消息与事件都回调给企业，企业可以调用API来收发消息、分配会话等<br> 注意：</p>
<ul>
<li>企业须已在在企业微信里使用微信客服且已开启API，才能正常在企业微信里调用微信客服相关API。</li>
<li>开启API后，仅可通过API来管理客服帐号、分配客服会话和收发客服消息，开发者请做好处理。</li>
</ul>
<h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><p>客服账号管理</p>
<ul>
<li>添加客服帐号</li>
<li>删除客服帐号</li>
<li>删除客服帐号</li>
<li>获取客服帐号列表</li>
<li>获取客服帐号链接</li>
</ul>
<p>接待人员管理</p>
<ul>
<li>添加接待人员：添加指定客服帐号的接待人员。</li>
<li>删除接待人员：删除接待人员</li>
<li>获取接待人员列表：获取某个客服帐号的接待人员列表</li>
</ul>
<p>分配客服会话</p>
]]></content>
      <categories>
        <category>企业微信接入</category>
      </categories>
  </entry>
  <entry>
    <title>内存泄漏</title>
    <url>/2021/11/17/fe26308ea62e.html</url>
    <content><![CDATA[<h2 id="内存泄漏的情况"><a href="#内存泄漏的情况" class="headerlink" title="内存泄漏的情况"></a>内存泄漏的情况</h2><p>1、静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<p>2、各种连接，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<p>3、变量不合理的作用域。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。</p>
<p>4、内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</p>
<p>5、改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露<br>6、内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘，对于这个问题，可以使用WeakHashMap代表缓存，此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值</p>
<p>7、 内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的API中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存他的若引用，例如将他们保存成为WeakHashMap中的键。</p>
<h2 id="内存泄漏的现象"><a href="#内存泄漏的现象" class="headerlink" title="内存泄漏的现象"></a>内存泄漏的现象</h2><h2 id="定位内存泄漏"><a href="#定位内存泄漏" class="headerlink" title="定位内存泄漏"></a>定位内存泄漏</h2>]]></content>
      <categories>
        <category>内存泄漏</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/07/14/052711817fb7.html</url>
    <content><![CDATA[<h2 id="单例设计模式（Singleton）"><a href="#单例设计模式（Singleton）" class="headerlink" title="单例设计模式（Singleton）"></a>单例设计模式（Singleton）</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>模式定义/应用场景/类图分析 </li>
<li>字节码知识/字节码指令重排序 </li>
<li>类加载机制 </li>
<li>JVM序列化机制</li>
<li>单例模式在Spring框架 &amp; JDK源码中的应用</li>
</ol>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>保证一个类只有一个实例，并且提供一个全局的访问点</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>重量级对象。不需要单个实例，如线程池，数据库连接池</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="1-懒汉模式"><a href="#1-懒汉模式" class="headerlink" title="1.懒汉模式"></a>1.懒汉模式</h3><p>懒汉模式：延迟加载， 只有在真正使用的时候，才开始实例化。 </p>
<p>存在问题：</p>
<ul>
<li>线程安全问题 </li>
<li>double check 加锁优化 </li>
<li>编译器(JIT),CPU 有可能对指令进行重排序，导致使用到尚未初始化 的实例，可以通过添加volatile 关键字进行修饰，</li>
</ul>
<p>对于volatile 修饰的字段，可以防止指令重排。（具体原理后续文章展开）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123; </span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123; </span><br><span class="line">                    instance=<span class="keyword">new</span> LazySingleton(); </span><br><span class="line">            <span class="comment">// 字节码层 </span></span><br><span class="line">            <span class="comment">// JIT ， CPU 有可能对如下指令进行重排序</span></span><br><span class="line">            <span class="comment">// 1 .分配空间 </span></span><br><span class="line">            <span class="comment">// 2 .初始化 </span></span><br><span class="line">            <span class="comment">// 3 .引用赋值</span></span><br><span class="line">            <span class="comment">// 如重排序后的结果为如下 </span></span><br><span class="line">            <span class="comment">// 1 .分配空间 </span></span><br><span class="line">            <span class="comment">// 3 .引用赋值 如果在当前指令执行完，有其他线程来获取实例，将拿到尚未初始化好的实例 </span></span><br><span class="line">            <span class="comment">// 2 .初始化 </span></span><br><span class="line">                &#125; </span><br><span class="line">             &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-饿汉模式："><a href="#2-饿汉模式：" class="headerlink" title="2.饿汉模式："></a>2.饿汉模式：</h3><p>类加载的初始化阶段就完成了实例的初始化。本质上就是借助于jvm 类加载机制，保证实例的唯一性（初始化过程只会执行一次）及线程安全（JVM以同步的形式来完成类加载的整个过程）。 </p>
<p>类加载过程： </p>
<ol>
<li>加载二进制数据到内存中， 生成对应的Class数据结构， </li>
<li>连接： a. 验证， b.准备（给类的静态成员变量赋默认值），c.解析 </li>
<li>初始化： 给类的静态变量赋初值</li>
</ol>
<p>只有在真正使用对应的类时，才会触发初始化 如（ 当前类是启动类即 main函数所在类，直接进行new 操作，访问静态属性、访问静态方法，用反射访问类，初始化一个类的子类等.）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 饿汉模式 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance=<span class="keyword">new</span> HungrySingleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-静态内部类"><a href="#3-静态内部类" class="headerlink" title="3.静态内部类"></a>3.静态内部类</h3><ol>
<li>本质上是利用类的加载机制来保证线程安全 </li>
<li>只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一 种形式。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassHolder</span></span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> InnerClassSingleton instance= <span class="keyword">new</span> InnerClassSingleton(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span><span class="params">()</span></span>&#123;  &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> InnerClassHolder.instance;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>设计模式</tag>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2021/07/14/bfe50c9d7eb1.html</url>
    <content><![CDATA[<h1 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h1><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol>
<li>Cloneable接口/Object#clone方法 详解 </li>
<li>浅拷贝/深拷贝</li>
<li>序列化机制实现深拷贝</li>
</ol>
<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义:"></a>模式定义:</h2><p>指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>当代码不应该依赖于需要复制的对象的具体类时，请使用Prototype模式。</p>
<p>优点： </p>
<ol>
<li>可以不耦合具体类的情况下克隆对象 </li>
<li>避免重复的初始化代码</li>
<li>更方便的构建复杂对象</li>
</ol>
<h2 id="Spring源码中的应用"><a href="#Spring源码中的应用" class="headerlink" title="Spring源码中的应用"></a>Spring源码中的应用</h2><ul>
<li>org.springframework.beans.factory.support.bstractBeanDefinition</li>
<li>java.util.Arrays</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
        <tag>Prototype</tag>
        <tag>浅拷贝</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集</title>
    <url>/2021/07/21/4249c39389fc.html</url>
    <content><![CDATA[<h2 id="对象已死判断"><a href="#对象已死判断" class="headerlink" title="对象已死判断"></a>对象已死判断</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法实在对象中添加一个引用计数器，每当有一个地方引用他时，计数器就加一；当引用失效时，计数器减一；任何时刻计数器为0的对象就是不可能在被使用的。</p>
<p>引用计数法回占用一些额外的存储空间来进行计数，但是原理简单，判断效率搞。但是看似简单的算法有很多例外的情况需要考虑，譬如单纯的引用计数法无法解决对象之间循环引用的问题，这就需要大量额外处理才能保证正确地工作。</p>
<h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p>对象objA 和 objB都有字段instance，令 ，objB.instance = objA。此外两个对象没有其他引用，实际上两个对象已经不可能在被访问，但是他们互选引用着对方，导致他们的引用计数器不为0，引用计数算法无法对他们进行回收。</p>
<p>代码样例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testGC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>可达性分析（eachability Analysis）的基本思路时通过一系列GC ROOTs 的根对象作为其实节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain）如果这个对象到GC ROOTS没有任何引用链相连，或者说不可达，则证明对象不可能再使用的。</p>
<h4 id="GC-ROOTs的对象"><a href="#GC-ROOTs的对象" class="headerlink" title="GC ROOTs的对象"></a>GC ROOTs的对象</h4><h5 id="固定的GC-ROOTS集合"><a href="#固定的GC-ROOTS集合" class="headerlink" title="固定的GC ROOTS集合"></a>固定的GC ROOTS集合</h5><ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象，比如使用到的参数、局部变量、临时变量等</li>
<li>方法区中类静态属性引用的变量，比如java类的引用类型静态变量</li>
<li>方法区中常量引用的对象，比如字符串常量池（String table）的引用</li>
<li>本地方法栈中JNI（native方法）引用的对象</li>
<li>java虚拟机内部的引用，比如基本数据类型对应的Class对象，常驻异常对象（OutOfMEmoryError NullPointException）等，还有系统类加载器</li>
<li>同步锁持有的对象</li>
<li>java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存</li>
</ul>
<h5 id="非固定的GC-ROOTS"><a href="#非固定的GC-ROOTS" class="headerlink" title="非固定的GC ROOTS"></a>非固定的GC ROOTS</h5><p>根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。（跨代引用问题）</p>
<h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p>引用计数算法和可达性分析都是通过引用来判断对象是否存活。一个对象只有“引用”和“引用未”这两种状态在有些情况下不能完全适用。比如缓存这种对象，当内存空间还足够时，能够保留在内存中，如果内存空间进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象。</p>
<p>JDK1.2后引用的概念进行了扩充引用的分类有</p>
<ul>
<li>强引用 Object obj=new Object() 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用 描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用 描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用 也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>垃圾收集算法</tag>
        <tag>对象死亡判断</tag>
      </tags>
  </entry>
  <entry>
    <title>字节测开面经</title>
    <url>/2021/11/04/e0b00fc968c1.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2e36186353c9624cd9e629d2d8463e7add3651002d716f67bf27635fd7f11dc3">4630436162ade97ba2718b7d0c4b3b636438bb933c28fae3a0e8db9d93a0a3f4629db893dc2558a111361d95324c3440e6a7a9b0523ccc7631aab74c40c585e84867e364a6fc1bd24e8bb1ab07eb8ea467602bdbe68ed9ab688e8094b41e35f66b9dc8b7551ae9806e0de4d4d76e21c8e992bde8673cb42e26668b5ee741c94ea28c6f32da0f0614057e8406d92903c81836122dc4783e2ee58b69625c85b325f57e84006cddec22b71b41dcbcbda2bc47d65acd853acb0e7e109a2774ff7fe414e2cbd4decf099b163a83f27db141eb7d639589d514c30a0ffa0de16dad0cc6125f21fdd132d568379d74be7d4589c77bc2f4095a6483f848996fc1c98030131d7ab316c45d551ebcb54158d27c3734b66b0234647d362858c66ae260ca13e2ef0ed179d3b46637fedad6c5c93f8a5e64ae8046f5458f8a8ee920f110c9ffc27471a015d1534a54b971245720d0bb094380cff295c5bcd1c463f23668a19e8696ccd9707ce32adbb2455a62deeaca995261a80bd8cf06a107b256b57b0b5110026a871898017fe42130e75a31d0c1cd4e761ac2787dccb4d6ca304442e44cc0ac355041614a4268ba71f4d4a705bc2905a5553a9e3b752ba2ba39d20ab6e5a51313fb705d9bc1565a6097fcf4b29a914d262a28cdee4feaafd23779339eb6057ad5c242ba4a599eff7446c047de0c7c87b25ebc4c37fb434ab2748e75312935f72315ce29ec4840a9dac2e10d113beb254e75275a02427e888e8cd35c36b678aed3c7520ad3ea9902367f76ef8cb7e1d90c9c271ed9e4e4ba6ffa95bfec892bf058488d274f819d74c84b88c0c956c49c541b2aac32acb3ec2509a28eddea9943822dcb7e04cfbf3842e14d6b78e275d6267ad48998820126d2f79856dd6eb534b926a7af5498f846097fe56e954e8231de76b317c891e30443de5d373b736406553eaf61d692cf94b5febfc8ed1c687df48e05f3cdca8a93bc596c4562aecf191df5ea7484b64e9b9bd33b9bb44c548fc30bc13245a2dec38fece4a40797c74e1d58993747eaf2a92685a14afb81e319d6da3c52f4c5015815421d27dc01747b5883972924fba258ba7b482efed3ecba7deba48b9ad4acbbd805c9c53cc77ebca848dbf734130ff7efe46586137f1b2deabc3bde45d1396e95437b30b6549be2d06e6b466fffdee78108d9d11f7de320ea9d8375d6c76c0d2eed2cac578d04a7662286e144a7cdee73cf535497a49fd48f1875cac21e4058710d48bfa934c35b668dc72a11209095bbbb66989cb7bc38774ffe1b478c792cc23d751dfc60e872c5c1ce2c4f7691bfbc4244972379f0800bd27087ac02c985ca5d02600920407f7e3f088f91dbe403ce42e8d863092eef539aa8495fc751b20bd803278343282f48bad141abf3e6bea0c450aa6b01221b95ab6202e915425a5eeb2a65a482a9476ee579baa2da81033ffba1c8c125d3f8a2c7017f96f7612ad182b5c5f2eb246c45cc610bb8e01097e747d8ed772c0e906bbca8439216f91909c65c5f8e8a7ae002ef1bf7f5c2483ed098ac71c84c2560ff557a9a17e3eccc3483ff6533f1de54fdcc0bb19b29d3498ec15fd2602c57ab7f4b82fc9a21b4f1b7b6e08e76447f3522e51e2c9dc02bfeab233e42621d521fee716142c6f1c51b39ffbefa0b82a689f63a3011f3233693de7674a60a2bade4a0201107b13470d07b2e4705fe44758ec1aa0cb8dede31809f13ee7aacea46cf905cafa879308fbb6d0d7328989a70569992ad8ca99c7a03e981eaa8525d8507e6c1265afe283c563f3b2bf7965c87c5d57de86cdd5548391b6347a7a373e9e23c5d828d93c66c7b6af10096e22c8499ab8a4ad6d80d13beae0300ed00fe1cb469324d8adff63e2e41b040fec03bbc997a404fd163ef397c2b2d364a7b4d290bbc50fdca3897739df219d7566c2cd04ffc454335d1bdcd117037073158f7df8311d14ca1a8d60773a378f8c4715d7467ecba236146c51db6a083b359f2f768c6e2edd10125738454c00fbbd1ef22230d0a1952654e715423ea930d9ed3176c97895e08bbcc36b540d2d62277a509092e18c054b466b8cf60cc07756385e2db2b8db9ab81606f9540186631153ef902cb2e39c20c0692d04c0d7fd14ac735822322c7df9c17893aa359af99eb3d6d37d0afe53b86487e8c60d25f44a0090249fbd016dfc059ad1eadae5d3db53352a2f56d673c0961f19e0c2038c9cfca56b636029c0e38e38d5a3a418adc1adde3c6a946f4998d6712a7777e3fc372e07f25b943b332b185abc856b7ed59c15eebd70a45bb4527cf4e20969f2729d74e6706deb94814c62658bf648ffeb2c7fe160fc7eaeb4f3bd207ad91d540906b5a95119be8d7892a859307a9d10d88fd8d7d89d356fe06c717dd6cbe077cf9c4f8788b66a299bdd649ee60ae8d1a2115ac147d47bed58303a7720f609929421ac20894996083a9c7ed12b57f7da5c8326ecfac0f5fad523c6ccbcb4567b93bbd22c12476320754bd2e8caf4c6c7f595a6d117399fc8fbd859f02c3c8edd9975415ba3ed178f9b29e5f525692866a28b4efeedf7c34e6469e46799ab7d772ce1da52ea66451143e8e031037095130b59e114f5332e8249887be11b340ce85859a3d4e552ca0bddd3dde953744a017ca457e5ac6be8ac98bcc4224a0542a774d05322c33d813d2480a1871554d56e365e83e7084362b6fe61ffe2b857bf474ec30c1f73bfb7c18193902893c2704cca05d9ffd8231052b565814e345b1dacd383e8e2b9083039b84e1c6c12fec5eb984687e92bdae6e4c6c4748b51a37f2d54b04991b8e524560e64c479cfba102cc6fe4c2edc05b51bd63c8176d6ef69f7276dd5286ffee96a99d072753d99556405d5502bdbc330527c33837b74389d96ee955b6a878f6674d7d59bfe92309d222f1ac02fd32ee8c18957199fc8b36d2ba3fc0b52c2f0cbce9ea2dd25e207faac57494d8d1285938b21bfc14f4d082c3cf0e99d7e3a2ed36534c1ac1cc86121e26f832321d071ba87ba543aea53e10b09d61429e4250f7a0b2ba91274e42d6b60d12691bb97e3a5b5e36dd8df48ff32d8084a4fb073e4289d1bc12dd3e37d6e508cbab0019cf273b4489155ead52c5ad712cc9b5d83d59821614828905e0349c7f7a6f48c43263e9b6fc0fac072a7f03130465a85d5220a454affd66b5dd507cff0bfa19e80908d30d39a0f58ac5352ce9752a47d37aad69a9884719d4c32974bedde32303d9a95a5ca67980b816e33103a6b66b2883a06ef062adc0e7becbfa4496712a493b50d425a19c1bd392991c2a0f106eb6cf5bed404f7b07dd44bfb3b2f4251969e9883032253df07a7724c17135bfc9b7169cd943c56d4f97a80a363da0e414eb75fce4575039e6f26b6b6419a8f4d6c1b668058bc356804419a002d9837a0b6877dd79172558002a1c527330fa095f209d64800f7de00ea27a1398a8da3903129a0fd536bffdc058ecfce41f421149e2e831f7b9999e813b56eb76e01f087f0eacacbd451680060c09b0171abbc9b52b391cf804b4a520d9c20435fc02c9b78c8422f1ca53fd3fc774c955f0146e4d648bd625e8c60e7ecb2c9eb363066fdbbf0a191c40a74d7ee58a4e5e4be7df826682c49aac3e850fe185c5cd171acedd77b13226810b721bad3acb699a2c75f85d72a6400a910c3e7c6320c52b86cdf42f33d83846ce9a248cd1318741125ede24c867a74d3ff09c2ec20f46f4add6b410e21486c0074c63b46f2a1ea46924f0e6b9c5994c25c411c317cd23234e7f827d8ff25366454ad008e7566af86acc4a890f4f18adf5f0526782b90e8e9ad3609cc9ba489857f782c7e1ce7ee4659d975859b4833df5ec7698d5231fc1f6b616094ec36ef0a76d5d07185af0b6c637cf54fe7766ad4740888d145e49f2ac4b456a8348adfd0e95999c05859cb686239d9a59dfc832d46c8b3d871378ac821f2504dbc3ef6fe15cfd41558361c18202e9301ded57fa32ea4f2b2dc061d744d3e9a87c2edd22c0320fa81acb9b410e65498e1d28520fc894b54213cf6c7e19e5090a0bbd98f582d3fda2c1e0e14eb465d679e48228566370967e1f781bfe1fd61c6832588068a79e21bfd546a75848689e215e51324efce1c0ee47709fa736b466abae9dcf99cd7a0ee8d79a5eaebf6cfbb9e13d34e81a96bc9fcb891cc5fc5cc470b0c6d740f01534a8957d0229982812cea034164a9a1ad879d91f41d41a8dbc2b2c05a5d739993a2a74c9596391d679105b2177414b2df2ebafb63ae235fb3c85b5e40533ef3db03029ffae2e3399e17ed218021f5597fa6d64b1ea9399cc37ee256db724eaedbf9d70027a4a3bf44b2e2273351ad00801d22beb4ff146627095b415e8e63e92200b4d5560b1a486a600134e0d97d1b215b5c2469b90b55981279f2624214aee5eef8735794ba740316556c8aaa3ed32ae15bfddf73da2e1f176b6c267e2c1d7a2fe9e210c0f9f1800cf9f781eb0bb82f9fc8a72f32ec511193c06f785ae90a7e88872583088cb355b03eeaf645b01b813bbe3e2e96b89b3626530e73a30c550ddca199089c2b65d49b925e0e08cbbc1399f59c682ca4a1a5f3862940fc82e8dab9b46077f94d9e89d84c000bb3a1f10fce8a8ecdc112b5a477c7bc3a36c2845577f3fecdd4eca79f6d21a4ce359d9db9e36b4aaec5cddfdd955f90dcd19d9204622f5dc20507959ae62fc4b1b8676b5d0bfdc08e1c1f02f6a03a7dd83492fa7828ac73685402539f8745a84c3e7f21d7db7548f4c519d343d221c7ba61545b9413e723240331d9fe0efa94d7eb90534baad072ce39f304bd597bd1a3f1a013429c78f9c4b457c6cd9213555b87ed92b68b30c604b7f3c773b912e3fff8848124de83dc0b3595b96e47d2a665bd85ecfa3025cefdc2fcf507f2d2b2f66aafe658a75921b83df2862e377a85ed496daac8e95f70ae7deeedcd27d91deb4392c38d156a983986c54e49eec5206fc3767243b7ed3e602d34ef2819b8155f860ce51402f02c8541411bc7a7811cbaaf53855932b600f9c111e8232408202a9238d5a89c381a79d2ee5b229147f32092c19ae139a5e31776ae73437a8bf51dafe631d87e5525873b70188a8b8fa383a9440ff61f86f2278f8981c4c26ba6b556c7ece58285811fcb5b88192d7571638b328a1c3c0fc4c494920b0b23b4527e6595918ad3a95f7dc2473866c81537ca9debb56f404ebe8c03d91e2e2bb5f74df08ff9ab0035e1bf9198cbe8916fd2299e01a783f659f5f9f81ca4ccc146a8b2545d3d29be5d74a2ae56e27ffca324ae68073035f5b57635c2ee7215c7976c35442c7515d2f2db488d77ae92e17b95b4f9924c8678b13b7bd47975ac794425f87534cb59b03699a9af5a303ace7b073fd13d1be49926ad10dbde44972284a6e062bb4d98d12dd2b9d44d1eab305fd08ef6f327a7ca65eb54afcfca90dcf9c38987d71c7c41d296291f6f8c202d9c5c486fecc9fbdf35aa8c73304fa9326b860e1afa23799a0f46d0137961c1fcc49eef2a45c4886204ac52896c607adb82c1fd5b4312b3879db1cbdaf36af1bf5a715c603ab3e054d032e2ca2fd25144b25de7a5a5a01c9f54551a93ecd4982ee73dc22648353c44d62205bdc2ae68870042ede7cb1961335d0341ef019788b54a8a08395ba987412b35b77766a6b2d536d31983bc1466b69e14a54c33f2f3fc335fb2e43b01072a5564b99f76e39d4e495e7f4084793e3207ea9c39d3b3514c97933085cebdf9ab57a5e40ced26892ed79add0f990bc69b500d834bfe1f7b2d54636095008ab24e058e7aa1ffc43f6d33ecd59b1744ab79e97c7bf09126d8bb85ecfe3104505baefc39c16549de0885a4903d59c142c78c0ac6e4d2b4afd93829cff36fe06cdbb42c62747fa58871f9f453452d6089634dde61ca9e9240b3460053582ed85dd679c84aac84fd71f102b52e1fe7d352a14c4ffa6e4cda762926f3e9c1b590f82788f25ff2b6cd5e78ecc16c60d147d5d51b909b87dd82d49f195495d3e59d5af89c4ca44b1614721da856eb0e26cb158b71ce8f465a1374dd371a46b69bca7fee3610db075e4fec92c6b4315258bf4f4497bd6d4f45b82cb2cc547ee1e43319b308f09a0b6c3a9464f89a6fa9140df5a236edc4415f7eb5cd941d48879533a2f290ccf6f68fcb476b6835f67c6bfd32c2eea9ea2aada571378168368e833ea0b2ea1b47969ab8ff2ff6227d91a87b6e4d86dd3e3ae279a4f4de941d15147d5eae3d98b4f85fc348f09efd9364fb6a9a91c8420bef846f6172c85e1409afb484f2dd5b6ea0133684aa90632a24e432b4ea93a54321abf350dcb9271fe822f65c19b37bf3dd556bf02fda95ee42b40793338bdc8fddb264680229a2d630c69505456cc399b1ecd9e7f896c9fcf2c611900f7d99520175752f1845b0322b0c7056ec57f96adedd17a6463f0b3cb0e628149f6a1d45539572cbecb4bfe28124030ef7c9ba72920f387670db61bf3c1434bd86aeb4d842c9b8fbf74a0614204097a2f560a56537065e01139165c3a400315b3ecf695b11b3e8fd1875a9d84fff144a4599b23b77a021225d380d130a697e42bc1d3a2f50848a4aa54cc0f7fa4057092ad44b89d52a829fed8584d6b29729cbd7d8bded35a03912c6dc95d1f2ea7d81cb18e7bb10917c58666ceb9a529a08c628c82792cf706163175bc0c84a19f3299c2eca2c8fa4ea21c8cf51777392481883d70333a3fc6d39608e7f7afea45fed5c5abe10c3c74e5cf5e7f512ab12f319ae41f863687dcba899f64765e8f5062e58ed65913e23f60a73ede99afe5d01704536ddadd1637df6369abfb31d7f6bca084305fa6a6963546cc549bf23b9bda09123b9d1b2883dd12e2b0af59253b3c293c0b4f99d7bf95686eaf28dec2a31db13dc79244ba21841b1249afc37f4dd4bb4460322fdf42d85a5d7f430f9404096f40f402a2b5421c4a11ea8999ca12ea7ef19fd1ca0964e13dc85fad798cfa8498e8c85c2d0dfebae51be9abe7519e83d1605be6561d01abb54815916dddda36c2b673facc33278f267c3c7031136cbb3dfc2e21e43765f89a2e5c35cc74d366167d8a2c7c10589746be8e2625019c4998154918cd3b3d747ff0e844cb85b57d37cfa884cd9c27c371468228ebdaf588ea37f9f6fa7f782271fa5d34c3daa69d1a9707a00030afff16e9025586c189f6aef9d7e7e9be27599ea62d007b50cead821e8fd1ee587401f14851b7b1941de49f8585db48222f3c1422620b0eb72840bc380d183170ea6d66824acbde16ee79ee5e24597b6bbdcd595d059ab8da0dc2ee31b20f38c5676abd74ead71c4e2bc4a4a7477bf7de65e478f56145025c4953fb83e4302ce03c3c4168539528eb8670a6cc544a4b6a337e6bb0e6a94cda16cfb8354708e5ff33f87c93de8600ea34c8b65ecf0ea0e463a829c7bccb2c0fcb25b8ca7bf6f200453f2272985980a9a243e5232adfb2f614dbbe59a5a2ebcb4a32b96cbdc383f1ab4809ebb21ab88de9662d46f937dbc10587b4004eeef3e8374541f0d05a2422c170431f4d168ff24d0eb188a8d35a30f6763c945145207b57282e4881bcefc0a22f4a62c0fa99bf6f36292393ccabe9f92dcace0410303f025ae45f0cb7a43016f7f370fa9c92dc790ea3b8632312540e7bfc250f13f8e6f059b029fc3879311b95e2d5fce87d24b4e1d947c4e0a6134a86b431aef4a3ed8d4e26f1edb9cd8839727000aadc1df1afa515be83d9a799a91d9ce6f388dcf7310342708f4b7fdf6799a5d879856dcc41249235b9fa5f7a7c40a5920e700d8c9615d79d03a0b69c8a6aa963b7b772bda3720b2cb142e75f55d3f70752e59e7102fd940967bee596a035426a3ee22aa444987f420ca9ca7896cfbdcace5935a736a420a7dcd7aeab050fcf789ab4cb7917ce07ba3bd07d3fb57428cf6d6faf485b754ce99e79b482a7a3c58a63578e6ff12a54e6fdb3c1d1562cfd8a6c468c45d5049a0ec3eb11038b2ad5487e3151abf868d26146d7a9c94075697cbcb624085b28d69cb6c71cb3cbbc6122c911cfdd498014c931bb85ff7cee9a70ce9551e1455da0c5d2d1257df9358545235226473e7541706257af0564834d0c2ad447ce375b9e5d7e1612162bd57d874201819bddc8a1ef29b2986dd49bed89301980269b2904c2f5eeaad73b5531f79a2a87681ad201042a04d4846e473c580a6fdaf1851de3f9f5cc5b60f556a7014ceb68a59a4617f5a38826c32d23ee6e624b5cc644438dda1335687a7d5414e8a03bac97d4783f67b32b94d1cb4b5176a4c751cbd9936f2b9d1a0393e908841c5158a3bca8808df8e5aa8ad8d154672e999ba836ac46b5611213a3f96e94e101653efa6c60ea2da0f073da3aa3a9a99133c96af69a464ffc08a9a948126dd46aae60b786ea1ac258db801f5e02ac6a241e37e90c39dacb0d3e5e6b2e97c6e8ebab0b7c4709009a561dc0203295adf88a3b9b72575e8891b18b7e76600e3f31491e060ab4673f1c07746799c905c03ef55d8ab87efab2c827ed9ae6de682b58d7099e31181278fb872cadcb4abe124b75b4a3d81f712459bb1b2bd1994352dc3c3aa5d9700b1ba6dec9d8e629e5c555149ce6d8df7ede0abf4e72bbb33f152e3eacf3e55af8b216ed43d9a538e74a9e19bfc802ce1c0dc5a4beaf92a0bba4e889efceef7fb8b3607d073929aae2c7ffb339d077aa90b5e45d27febf255583810a45df1c155cb08e99193f974761959bab2c0d5f31df7dd16e0b2cd2b6d1a5fd68c458a3ab0f53c6d7b4ced3f26ab2e38b0719f3d9f05903e778655f5de56bf346468556360410f07da26959986aad4325e330a31923d19b72fa928a0b5ea5dd9b0b49bcb36c7d45ab3f104ce933024beb60b4e65604d6af63023d56725c55db8e811067e3b7c48a0dd7cf570b6fcd6b212ed2c9db7623bb0124fb79b49785e9dda749e633fe2330dfd49ef9ebc2955b137fd65afc4a53c4f3f73da96179fd633dd3436dc7d723abcd17158871a3faa2927f98c2b8d694002de7e4f89decc9e57e572e97eddd52ece63715b72395f8b577d1b37b1a8526925067e336bf9e4c468907e8821605699a6acc91affd60c45a2f8dd3601cca7f2ccc64539792b501dfb0e82d9f24b0e2f4cd1a1aec86900e47674023cb7d76862d3a6d8e2a4765793f23e963c62a0f65fc46aba50be7f6164e9c5862f740cd49820c1873ed5719aaebf89534677f4e839dc54d05a662ce2c701f2b2a45b2bce3c80e19d2049a338b188ec3be301cdf304d9a99c219b245c557e5934837cd3dba663c3d0fdd3f25ba2be6c4729a8ce659df6db1cd1b195f964bbd0c3262ec0f6b28ace2fa9048b24f0c0e207d316fb8ef0eb8b1dd383eb65b99b214379065bc57986ff015799b3fec0687df25e03956b2e9d331d1125511030d0983118fab471bab1e9af766279d1d31b43831c5e2f36cff24f9a94ac0b57c7f5cd732138f0df7008641a067a9d63edf8809c6d86d975de6b835fc003108317d1665eb4d7496d4985fbcc907c2ad635c4ab05c</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">这里有东西被加密了，需要输入密码查看。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>数据库事务</title>
    <url>/2021/07/27/d92c84f925a5.html</url>
    <content><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h2><p>事务（Transaction）是数据库区别于文件系统的重要特性之一。在文件系统中，如果正在写文件，但是操作系统突然崩溃了，这个文件就很有可能被破坏。当然，有一些机制可以把文件恢复到某个时间点。不过，如果需要保证两个文件同步，这些文件系统可能就显得无能为力了。例如，在需要更新两个文件时，更新完一个文件后，在更新完第二个文件之前系统重启了，就会有两个不同步的文件。</p>
<p>这正是数据库系统引入事务的主要目的：事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。</p>
<p>InnoDB存储引擎中的事务完全符合ACID的特性。ACID是以下4个词的缩写：</p>
<ul>
<li>原子性（atomicity）</li>
<li>一致性（consistency）</li>
<li>隔离性（isolation）</li>
<li>持久性（durability）</li>
</ul>
<h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><h3 id="A（Atomicity），原子性。"><a href="#A（Atomicity），原子性。" class="headerlink" title="A（Atomicity），原子性。"></a>A（Atomicity），原子性。</h3><p>原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</p>
<p>如果事务中的操作都是只读的，要保持原子性是很简单的。一旦发生任何错误，要么重试，要么返回错误代码。因为只读操作不会改变系统中的任何相关部分。但是，当事务中的操作需要改变系统中的状态时，例如插入记录或更新记录，那么情况可能就不像只读操作那么简单了。如果操作失败，很有可能引起状态的变化，因此必须要保护系统中并发用户访问受影响的部分数据。</p>
<h3 id="C（consistency），一致性"><a href="#C（consistency），一致性" class="headerlink" title="C（consistency），一致性"></a>C（consistency），一致性</h3><p>一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。例如，在表中有一个字段为姓名，为唯一约束，即在表中姓名不能重复。如果一个事务对姓名字段进行了修改，但是在事务提交或事务操作发生回滚后，表中的姓名变得非唯一了，这就破坏了事务的一致性要求，即事务将数据库从一种状态变为了一种不一致的状态。因此，事务是一致性的单位，如果事务中某个动作失败了，系统可以自动撤销事务——返回初始化的状态。</p>
<h3 id="I（isolation），隔离性。"><a href="#I（isolation），隔离性。" class="headerlink" title="I（isolation），隔离性。"></a>I（isolation），隔离性。</h3><p>隔离性还有其他的称呼，如并发控制（concurrency control）、可串行化（serializability）、锁（locking）等。事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常这使用锁来实现。当前数据库系统中都提供了一种粒度锁（granular lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。</p>
<h3 id="D（durability），持久性。"><a href="#D（durability），持久性。" class="headerlink" title="D（durability），持久性。"></a>D（durability），持久性。</h3><p>事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。需要注意的是，只能从事务本身的角度来保证结果的永久性。例如，在事务提交后，所有的变化都是永久的。即使当数据库因为崩溃而需要恢复时，也能保证恢复后提交的数据都不会丢失。但若不是数据库本身发生故障，而是一些外部的原因，如RAID卡损坏、自然灾害等原因导致数据库发生问题，那么所有提交的数据可能都会丢失。因此持久性保证事务系统的高可靠性（High Reliability），而不是高可用性（High Availability）。对于高可用性的实现，事务本身并不能保证，需要一些系统共同配合来完成。</p>
<h2 id="事务实现"><a href="#事务实现" class="headerlink" title="事务实现"></a>事务实现</h2><p>事务隔离性由锁来实现。原子性、一致性、持久性通过数据库的redo log和undo log来完成。redo log称为重做日志，用来保证事务的原子性和持久性。undo log用来保证事务的一致性。<br>有人或许会认为undo是redo的逆过程，其实不然。redo和undo的作用都可以视为是一种恢复操作，redo恢复提交事务修改的页操作，而undo回滚行记录到某个特定版本。因此两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>面试题 10.02. 变位词组</title>
    <url>/2021/07/17/63f05b595936.html</url>
    <content><![CDATA[<h1 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a>面试题 10.02. 变位词组</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<h3 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h3><h3 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h3><ul>
<li>如何识别字符串是同一个变位词？</li>
<li>同一个变位词如何快速加入到对应的数组中？</li>
</ul>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>对于第一个问题：</p>
<p>对将变位词进行计数排序，返回排序好的字符串，将返回的字符串作为哈希表的key，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        HashMap&lt;String ,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( String str: strs) &#123;</span><br><span class="line">            String key = count(str);</span><br><span class="line">            List&lt;String&gt; list;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                result.add(list);</span><br><span class="line">                map.put(key,list);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                list = map.get(key);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">count</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bit = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            bit[c -<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bit[i]; j++) &#123;</span><br><span class="line">                stringBuilder.append(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>leetcode</tag>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2021/07/14/cd123a041e29.html</url>
    <content><![CDATA[<h2 id="模板方法-Template-Method"><a href="#模板方法-Template-Method" class="headerlink" title="模板方法(Template Method)"></a>模板方法(Template Method)</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>
<h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractClass abstractClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">        abstractClass.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个操作的算法骨架</span></span><br><span class="line">        System.out.println(<span class="string">&quot; step 1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; step 2&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; step 3&quot;</span>);</span><br><span class="line">        <span class="comment">//步骤延迟</span></span><br><span class="line">        templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subclass step&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>当你想让客户端只扩展算法的特定步骤，而不是整个算法或其结构 时，请使用Template Method模式。 </li>
<li>当你有几个类包含几乎相同的算法，但有一些细微的差异时，请使用 此模式。</li>
</ol>
<p>优点： </p>
<ol>
<li>你可以让客户端只覆盖大型算法的某些部分，从而减少算法其他部分<br>发生的更改对它们的影响。</li>
<li>你可以将重复的代码拖放到超类中。</li>
</ol>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><ul>
<li>javax.servlet.http.HttpServlet </li>
<li>org.springframework.web.servlet.mvc.AbstractController</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀缓存优化</title>
    <url>/2021/07/29/b80307f408ca.html</url>
    <content><![CDATA[<h1 id="缓存优化思路梳理"><a href="#缓存优化思路梳理" class="headerlink" title="缓存优化思路梳理"></a>缓存优化思路梳理</h1><h2 id="使用Redis做一级缓存"><a href="#使用Redis做一级缓存" class="headerlink" title="使用Redis做一级缓存"></a>使用Redis做一级缓存</h2><p>首先对接口进行压测。无缓存的情况下QPS只有80.</p>
<h3 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><p>首先考虑所有请求都直接读写mysql肯定是不行的。那么第一想到的是加redis缓存商品数据。查询请求进来首先查询redis缓存，缓存不存在再去读数据库，最后更新缓存。</p>
<p>修改日志级别到warn，减少无效日志 性能提升10%。日志也会影响性能。</p>
<p>不走网关直接走原始服务器，性能提升。（网关处理也会影响性能）</p>
<p>进行三个优化步骤后达到1000QPS。</p>
<h3 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h3><p>请求Redis会走网络请求网卡也是影响性能瓶颈的原因。而且存入redis会有序列化和反序列化的开销。会对性能产生影响。此时考虑加入本地缓存，在高并发环境下使用ConcurrentHashMap做缓存。此时考虑缓存不能无限增长的，要对缓存加入淘汰策略。此时采用经典的LRU作为淘汰策略。</p>
<h3 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h3><p>使用缓存时，会出现大量缓存失效的问题，此时会有大量的请求去读取数据库。大量的请求同时请求数据库会导致数据库宕机。此种情况下要对数据的读取操作进行同步操作，阻塞大量的数据库请求。考虑到服务时集群形式，此时采用分布式锁来同步读取操作。</p>
<p>可以实现分布式锁的有：</p>
<ul>
<li>Redis</li>
<li>Redssion</li>
<li>Zookeeper</li>
</ul>
<p>最后选取了Zookeeper，Redis和Redssion会有死锁问题。</p>
<h3 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h3><p>当大量id不存在的请求过去会导致瞬时大量的读取数据库请求。这就是缓存穿透问题。</p>
<p>解决该问题的解决方案会有三个特性：</p>
<ul>
<li>快：处理要快</li>
<li>准：判断要准确</li>
<li>省：可以压缩数据</li>
</ul>
<h4 id="redis方案"><a href="#redis方案" class="headerlink" title="redis方案"></a>redis方案</h4><p>首先，快这个特性就要求数据要存储到内存中，此时可以考虑将所有的id存到redis中，可以实现快速准确的判断，但是在数据量很大的情况下会占用大量内存。此时可以考虑对数据进行压缩，但是要保证依然可以判断出id是否存在。</p>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>可以用布隆过滤器，布隆过滤器实际上就是一种压缩数据的方案，可以对数据是否存在进行判断。此时布隆过滤器放到redis。不需要每个实例维护一份布隆过滤器。</p>
<h5 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h5><p>布隆过滤器的组成：</p>
<ul>
<li>多个hash函数</li>
<li>位数组</li>
</ul>
<p>布隆过滤器启动时使用多个hash函数对id进行计算。然后将计算出的多个值在位数组中位置标为1。当要判断的时候就会重复该过程，同时去判断得出的结果的对应位置是不是都为1，主要有一个不为0就说明不存在。</p>
<p>布隆过略器准确性影响因素：</p>
<ul>
<li>哈希函数的个数</li>
<li>位数组的长度</li>
</ul>
<h3 id="多级缓存数据不一致问题"><a href="#多级缓存数据不一致问题" class="headerlink" title="多级缓存数据不一致问题"></a>多级缓存数据不一致问题</h3>]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存相关问题</title>
    <url>/2021/11/17/c72f053f30ad.html</url>
    <content><![CDATA[<h1 id="1、缓存会出现的问题"><a href="#1、缓存会出现的问题" class="headerlink" title="1、缓存会出现的问题"></a>1、缓存会出现的问题</h1><h2 id="1-1缓存穿透"><a href="#1-1缓存穿透" class="headerlink" title="1.1缓存穿透"></a>1.1缓存穿透</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>缓存穿透是指缓存和数据库都没有数据，而用户不断发起请求</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
</ol>
<h2 id="1-2-缓存击穿"><a href="#1-2-缓存击穿" class="headerlink" title="1.2 缓存击穿"></a>1.2 缓存击穿</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁，互斥锁参考代码如下：<h2 id="1-3-缓存雪崩"><a href="#1-3-缓存雪崩" class="headerlink" title="1.3 缓存雪崩"></a>1.3 缓存雪崩</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</li>
</ol>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li>
<li>设置热点数据永远不过期。</li>
</ol>
]]></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2021/07/14/5bfd545d12b3.html</url>
    <content><![CDATA[<h1 id="观察者模式-Observer"><a href="#观察者模式-Observer" class="headerlink" title="观察者模式(Observer)"></a>观察者模式(Observer)</h1><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p>定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题 对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>当更改一个对象的状态可能需要更改其他对象，并且实际的对象集事先 未知或动态更改时，请使用观察者模式。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>符合开闭原则 </li>
<li>可以在运行时建立对象之间的关系</li>
</ol>
<h2 id="jdk-amp-源码中的应用"><a href="#jdk-amp-源码中的应用" class="headerlink" title="jdk&amp;源码中的应用"></a>jdk&amp;源码中的应用</h2><ul>
<li>JDK: java.util.Observable </li>
<li>Spring: org.springframework.context.ApplicationListener</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
        <tag>Observer</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信</title>
    <url>/2021/08/16/f5eb7f7f9a8b.html</url>
    <content><![CDATA[<h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><ul>
<li>管道</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>信号</li>
<li>Socket</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道方式举例: | 就是一个匿名管道将ps aux的输出作为后一个命令的输入，而且很显然管道是单向的。双向通信就需要两个管道。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep mysql</span><br></pre></td></tr></table></figure>


<h3 id="管道分类"><a href="#管道分类" class="headerlink" title="管道分类"></a>管道分类</h3><ul>
<li>匿名管道 | （用完就销毁）</li>
<li>命名管道 FIFO （数据是先进先出的形式）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfifo myPipe</span><br></pre></td></tr></table></figure>
<p>myPipe 就是我们创建的管道的名称，linux一切皆文件这个pipe的文件类型是P</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">song@MateBooke13:~$ ls -l pipe</span><br><span class="line">prw-r--r-- 1 song song 0 Aug 16 20:51 pipe</span><br></pre></td></tr></table></figure>

<p>往管道写入数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; pipe //写入数据</span><br><span class="line">//卡住</span><br></pre></td></tr></table></figure>
<h3 id="管道的原理"><a href="#管道的原理" class="headerlink" title="管道的原理"></a>管道的原理</h3><p>管道就是内核的一串缓存，从管道的一段写入数据，实际上就是缓存在内核中的，另一端读取也就是从内核中读取这段数据。另外管道传输的数据是无格式的且大小受限。</p>
<p>匿名管道必须在父子进程中进行。而命名管道无此限制 在shell中执行 A|B，A和B都是shell创建的子进程。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>管道的通信方式效率很低，不适合在进程间频繁的交换数据。</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列可以解决管道的缺点。A进程给B发消息，A把数据放到消息队列里面就可以走了。B需要的时候就去取<br>消息队列是保存在内核中的消息链表，发送前要确认好数据格式。消息队列随内核存在。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>通信不及时</li>
<li>邮件大小有限制</li>
<li>通信过程存在切换内核态开销</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是为了解决消息队列存在内核态和用户态切换的问题。<br>共享内存的机制就是拿出一块虚拟地址，映射到相同的物理内存中，这个对内存的读取另一个进程马上就能看到。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>共享内存区域在多个进程同时修改同一个共享内存时，内容被覆盖</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量时为了防止多进程竞争共享资源的一种保护机制（PV操作实现进程的互斥与同步）<br>以上都是常规状态下的工作模式</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>linux下为了响应各种事件，提供了几十种信号，分别带别不同的意义。（kill -l 查看）</p>
</li>
<li><p>Ctrl +C 产生SIGINT信号终止进程</p>
</li>
<li><p>CTRL+Z SIGTSTP 停止该进程</p>
</li>
<li><p>kill -9 1050 表示给PID1050发送SIGKILL信号，来立即结束进程</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>socket来实现跨网络通信</p>
</li>
</ul>
]]></content>
      <categories>
        <category>进程</category>
      </categories>
  </entry>
  <entry>
    <title>零拷贝</title>
    <url>/2021/11/03/4104be24b2f4.html</url>
    <content><![CDATA[<h2 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h2><p>零拷贝（Zero-copy）：指计算机执行操作时，cpu不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p>
<p>好处：</p>
<ol>
<li>可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率。</li>
<li>零拷贝技术减少了用户进程地址空间和内核空间之间因为上下文切换带来的开销</li>
</ol>
<h2 id="Linux-IO流程"><a href="#Linux-IO流程" class="headerlink" title="Linux IO流程"></a>Linux IO流程</h2><ol>
<li>DMA拷贝：通过DMA方式将文件从硬盘拷贝到内核缓冲区域</li>
<li>CPU拷贝：从内核缓冲区拷贝到用户用户空间缓冲区</li>
</ol>
<h3 id="读取一个文件然后通过Socket发送的流程"><a href="#读取一个文件然后通过Socket发送的流程" class="headerlink" title="读取一个文件然后通过Socket发送的流程"></a>读取一个文件然后通过Socket发送的流程</h3><ol>
<li>File.read(fileDesc,buf,len);</li>
<li>Socket.send(socket,buf,len);<br><img src="%E9%9B%B6%E6%8B%B7%E8%B4%9D_files/1.jpg" class="lazyload" data-srcset="%E9%9B%B6%E6%8B%B7%E8%B4%9D_files/1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br><img src="%E9%9B%B6%E6%8B%B7%E8%B4%9D_files/2.jpg" class="lazyload" data-srcset="%E9%9B%B6%E6%8B%B7%E8%B4%9D_files/2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li>
</ol>
<p>在上述过程中经历了四次拷贝：2次cpucopy，2次dma copy，4次上下文切换</p>
<h2 id="怎么实现零拷贝"><a href="#怎么实现零拷贝" class="headerlink" title="怎么实现零拷贝"></a>怎么实现零拷贝</h2><p>零拷贝实际上就是减少IO流程中不必要的拷贝，需要操作系统的支持。通过直接将ReadBUfferkao拷贝到内核的SocketBuffer这样减少了一次cpu拷贝和两次上下文切换。<br><img src="%E9%9B%B6%E6%8B%B7%E8%B4%9D_files/3.jpg" class="lazyload" data-srcset="%E9%9B%B6%E6%8B%B7%E8%B4%9D_files/3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br><img src="%E9%9B%B6%E6%8B%B7%E8%B4%9D_files/4.jpg" class="lazyload" data-srcset="%E9%9B%B6%E6%8B%B7%E8%B4%9D_files/4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h2 id="Java零拷贝的使用"><a href="#Java零拷贝的使用" class="headerlink" title="Java零拷贝的使用"></a>Java零拷贝的使用</h2><h3 id="1-内存映射（mmap）"><a href="#1-内存映射（mmap）" class="headerlink" title="1 内存映射（mmap）"></a>1 内存映射（mmap）</h3><p>将内核缓冲区映射到用户缓冲区，通过虚拟内存器实现，（存在时空开销所以不适合小文件）。Java通过MappedByteBUffer实现。cpu拷贝次数一次，dma拷贝次数不变。上下文切换四次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;data.zip&quot;</span>);</span><br><span class="line">RandomAccessFile rad = <span class="keyword">new</span> RandomAccessFile(file,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel filechannel = raf.getChannel();</span><br><span class="line">MappedByteBuffer buffer = filechannel.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,filechannel.size());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-JavaNIO-FileChannel-transferTo"><a href="#3-JavaNIO-FileChannel-transferTo" class="headerlink" title="3 JavaNIO FileChannel.transferTo"></a>3 JavaNIO FileChannel.transferTo</h3><p>Linux2.1 提供了sendfile系统调用。可以实现内核读缓冲到socket缓冲的拷贝。一次cpu拷贝和两次DMA拷贝。两次上下文切换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File file = new File(&quot;test.zip&quot;);         </span><br><span class="line">RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);         </span><br><span class="line">FileChannel fileChannel = raf.getChannel();         </span><br><span class="line">SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;&quot;, 1234));         </span><br><span class="line">// 直接使用了transferTo()进行通道间的数据传输         </span><br><span class="line">fileChannel.transferTo(0, fileChannel.size(), socketChannel);</span><br></pre></td></tr></table></figure>
<h2 id="Netty中的零拷贝"><a href="#Netty中的零拷贝" class="headerlink" title="Netty中的零拷贝"></a>Netty中的零拷贝</h2><h2 id="哪里用到了零拷贝"><a href="#哪里用到了零拷贝" class="headerlink" title="哪里用到了零拷贝"></a>哪里用到了零拷贝</h2><ol>
<li>kafka</li>
<li>Netty</li>
<li>RocketMQ</li>
<li>Nginx</li>
<li>Apache</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>零拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>面经记录</title>
    <url>/2021/09/27/cf616068382c.html</url>
    <content><![CDATA[<h1 id="2021-9-27-小米"><a href="#2021-9-27-小米" class="headerlink" title="2021/9/27 小米"></a>2021/9/27 小米</h1><ol>
<li>上来自我接受问项目遇到哪些难点</li>
<li>动态代理了解吗</li>
<li>static了解吗（回答可以修饰类 、方法和变量）</li>
<li>内部类有哪些（回到静态内部类，普通内部类，还有别的吗？你用过new Thead(new Runable() {})）引导我回到匿名内部类</li>
<li>异常有分类</li>
<li>运行时异常有哪些举例</li>
<li>ERROR可以被捕获吗</li>
<li>序列化反序列化了解吗？有哪些格式，什么时候会有用到系列化</li>
<li>==和equals区别，基本数据类型能用equals吗？</li>
<li>集合类有哪些，我把list和map，set都说了</li>
<li>说说map的put()方法步骤</li>
<li>你没提到map的扩容，说一说map的扩容机制</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>面试题汇总</title>
    <url>/2021/07/28/cdc84b02548f.html</url>
    <content><![CDATA[<h3 id="服务器性能瓶颈"><a href="#服务器性能瓶颈" class="headerlink" title="服务器性能瓶颈"></a>服务器性能瓶颈</h3><p>服务器性能瓶颈主要在四个方面：</p>
<ul>
<li>网卡</li>
<li>cpu</li>
<li>内存</li>
<li>IO</li>
</ul>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>网络中通过ip地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程。在网络中采用发送方和接受方的套接字（socket）组合来识别端点。所谓套接字，实际上是一个通信端点即</p>
<center> 套接字 = （主机IP地址，端口号） </center>
套接字唯一的标识网络中的一台主机和其上的一个应用（进程）


<h3 id="TCP如何保证可靠性传输"><a href="#TCP如何保证可靠性传输" class="headerlink" title="TCP如何保证可靠性传输"></a>TCP如何保证可靠性传输</h3><p>tcp是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。</p>
<h3 id="什么是超时重传"><a href="#什么是超时重传" class="headerlink" title="什么是超时重传"></a>什么是超时重传</h3><p>在发送数据时，设定一个计时器，当超过指定的时间后没有收到对方的ACK确认应答报文，就会重新发送接着这就是<code>超时重传</code></p>
<h3 id="什么时候发生超时重传"><a href="#什么时候发生超时重传" class="headerlink" title="什么时候发生超时重传"></a>什么时候发生超时重传</h3><p>TCP会在一下两种情况发送超时重传</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<h3 id="什么是RTT（Round—trip-TIme-往返时延）"><a href="#什么是RTT（Round—trip-TIme-往返时延）" class="headerlink" title="什么是RTT（Round—trip TIme 往返时延）"></a>什么是RTT（Round—trip TIme 往返时延）</h3><p>[x] RTT就是数据从网络一端传送到另一端所需的时间</p>
<h3 id="RTO（Retransmission-Timeout）"><a href="#RTO（Retransmission-Timeout）" class="headerlink" title="RTO（Retransmission Timeout）"></a>RTO（Retransmission Timeout）</h3><p>RTO：耗时重传时间。</p>
<ul>
<li>当RTO过大时，重发就慢，丢了很长时间才会重发，没有效率，性能差。</li>
<li>当RTO过小时，会导致可能并没有丢就重发，于是重发的快，会导致网络拥塞，导致更多的超时，更多超时会导致更多的重发</li>
</ul>
<p>根据上述情况，<code>超时重传时间RTO的值应该略大约报文往返RTO的值</code></p>
<h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3>]]></content>
      <categories>
        <category>面试汇总</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法得性质</title>
    <url>/2021/08/16/0f646613617c.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>算法种类</th>
<th>最好情况</th>
<th>平均情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>是否稳定</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>直接插入排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>简单选择排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>希尔排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2路归并排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>hashmap</title>
    <url>/2021/08/17/18c3a0674c7f.html</url>
    <content><![CDATA[<h1 id="HashMap源码分析（jdk1-8，保证你能看懂）"><a href="#HashMap源码分析（jdk1-8，保证你能看懂）" class="headerlink" title="HashMap源码分析（jdk1.8，保证你能看懂）"></a>HashMap源码分析（jdk1.8，保证你能看懂）</h1><hr>
<p>现在的面试当中凡是那些大厂，基本上都会问到一些关于HashMap的问题了，而且这个集合在开发中也经常会使用到。于是花费了大量的时间去研究分析写了这篇文章。本文是基于jdk1.8来分析的。篇幅较长，但是都是循序渐进的。耐心读完相信你会有所收获。</p>
<p><strong>一、带着问题分析</strong></p>
<p>这篇文章，希望能解决以下问题。</p>
<p>（1）HashMap的底层数据结构是什么？</p>
<p>（2）HashMap中增删改查操作的底部实现原理是什么？</p>
<p>（3）HashMap是如何实现扩容的？</p>
<p>（4）HashMap是如何解决hash冲突的？</p>
<p>（7）HashMap为什么是非线程安全的？</p>
<p>下面我们就带着这些问题，揭开HashMap的面纱。</p>
<p><strong>二、认识HashMap</strong></p>
<p>HashMap最早是在jdk1.2中开始出现的，一直到jdk1.7一直没有太大的变化。但是到了jdk1.8突然进行了一个很大的改动。其中一个最显著的改动就是：</p>
<blockquote>
<p>之前jdk1.7的存储结构是数组+链表，到了jdk1.8变成了数组+链表+红黑树。</p>
</blockquote>
<p>另外，HashMap是非线程安全的，也就是说在多个线程同时对HashMap中的某个元素进行增删改操作的时候，是不能保证数据的一致性的。</p>
<p>下面我们就开始一步一步的分析。</p>
<p><strong>三、深入分析HashMap</strong></p>
<p><strong>1、底层数据结构</strong></p>
<p>为了进行一个对比分析，我们先给出一个jdk1.7的存储结构图</p>
<p><img src="https://pic4.zhimg.com/v2-13f265dfbfe4f6bf0505cd31d7b3cf47_b.jpg" class="lazyload" data-srcset="https://pic4.zhimg.com/v2-13f265dfbfe4f6bf0505cd31d7b3cf47_b.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>从上图我们可以看到，在jdk1.7中，首先是把元素放在一个个数组里面，后来存放的数据元素越来越多，于是就出现了链表，对于数组中的每一个元素，都可以有一条链表来存储元素。这就是有名的“拉链式”存储方法。</p>
<p>就这样用了几年，后来存储的元素越来越多，链表也越来越长，在查找一个元素时候效率不仅没有提高（链表不适合查找，适合增删），反倒是下降了不少，于是就对这条链表进行了一个改进。如何改进呢？就是把这条链表变成一个适合查找的树形结构，没错就是红黑树。于是HashMap的存储数据结构就变成了下面的这种。</p>
<p><img src="https://pic2.zhimg.com/v2-14ccbe757a467d874cb7999f62caddcd_b.jpg" class="lazyload" data-srcset="https://pic2.zhimg.com/v2-14ccbe757a467d874cb7999f62caddcd_b.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>我们会发现优化的部分就是把链表结构变成了红黑树。原来jdk1.7的优点是增删效率高，于是在jdk1.8的时候，不仅仅增删效率高，而且查找效率也提升了。</p>
<p><strong>注意：不是说变成了红黑树效率就一定提高了，只有在链表的长度不小于8，而且数组的长度不小于64的时候才会将链表转化为红黑树，</strong></p>
<p><strong>问题一：什么是红黑树呢？</strong></p>
<p>红黑树是一个自平衡的二叉查找树，也就是说红黑树的查找效率是非常的高，查找效率会从链表的o(n)降低为o(logn)。如果之前没有了解过红黑树的话，也没关系，你就记住红黑树的查找效率很高就OK了。</p>
<p><strong>问题二：为什么不一下子把整个链表变为红黑树呢？</strong></p>
<p>这个问题的意思是这样的，就是说我们为什么非要等到链表的长度大于等于8的时候，才转变成红黑树？在这里可以从两方面来解释</p>
<p>（1）构造红黑树要比构造链表复杂，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高。就好比杀鸡焉用牛刀的意思。</p>
<p>（2）HashMap频繁的扩容，会造成底部红黑树不断的进行拆分和重组，这是非常耗时的。因此，也就是链表长度比较长的时候转变成红黑树才会显著提高效率。</p>
<p>OK，到这里相信我们对hashMap的底层数据结构有了一个认识。现在带着上面的结构图，看一下如何存储一个元素。</p>
<p><strong>2、存储元素put</strong></p>
<p>我们在存储一个元素的时候，大多是使用下面的这种方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map= new HashMap&lt;&gt;();</span><br><span class="line">        //存储一个元素</span><br><span class="line">        map.put(&quot;张三&quot;, 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里HashMap&lt;String, Integer&gt;，第一个参数是键，第二个参数是值，合起来叫做键值对。存储的时候只需要调用put方法即可。那底层的实现原理是怎么样的呢？这里还是先给出一个流程图</p>
<p><img src="https://pic3.zhimg.com/v2-bb8ee0ee1c0cc51537ae5f8e02038102_b.jpg" class="lazyload" data-srcset="https://pic3.zhimg.com/v2-bb8ee0ee1c0cc51537ae5f8e02038102_b.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>上面这个流程，不知道你能否看到，红色字迹的是三个判断框，也是转折点，我们使用文字来梳理一下这个流程：</p>
<p>（1）第一步：调用put方法传入键值对</p>
<p>（2）第二步：使用hash算法计算hash值</p>
<p>（3）第三步：根据hash值确定存放的位置，判断是否和其他键值对位置发生了冲突</p>
<p>（4）第四步：若没有发生冲突，直接存放在数组中即可</p>
<p>（5）第五步：若发生了冲突，还要判断此时的数据结构是什么？</p>
<p>（6）第六步：若此时的数据结构是红黑树，那就直接插入红黑树中</p>
<p>（7）第七步：若此时的数据结构是链表，判断插入之后是否大于等于8</p>
<p>（8）第八步：插入之后大于8了，就要先调整为红黑树，在插入</p>
<p>（9）第九步：插入之后不大于8，那么就直接插入到链表尾部即可。</p>
<p>上面就是插入数据的整个流程，光看流程还不行，我们还需要深入到源码中去看看底部是如何按照这个流程写代码的。</p>
<p>鼠标聚焦在put方法上面，按一下F3，我们就能进入put的源码。来看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">     return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，put方法其实调用的是putVal方法。putVal方法有5个参数：</p>
<p>（1）第一个参数hash：调用了hash方法计算hash值</p>
<p>（2）第二个参数key：就是我们传入的key值，也就是例子中的张三</p>
<p>（3）第三个参数value：就是我们传入的value值，也就是例子中的20</p>
<p>（4）第四个参数onlyIfAbsent：也就是当键相同时，不修改已存在的值</p>
<p>（5）第五个参数evict ：如果为false，那么数组就处于创建模式中，所以一般为true。</p>
<p>知道了这5个参数的含义，我们就进入到这个putVal方法中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    //第一部分</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //第二部分</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    //第三部分</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        //第三部分第一小节</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        //第三部分第二小节</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        //第三部分第三小节</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                //第三小节第一段</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                //第三小节第一段</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                //第三小节第三段</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //第三部分第四小节</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    //第四部分</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看，这代码完全没有读下去的欲望，第一次看的时候真实恶心到想吐，但是结合上一开始画的流程图再来分析，相信就会好很多。我们把代码进行拆分（整体分了四大部分）：</p>
<p>（1）Node&lt;K,V&gt;[] tab中tab表示的就是数组。Node&lt;K,V&gt; p中p表示的就是当前插入的节点</p>
<p>（2）第一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">       n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>

<p>这一部分表示的意思是如果数组是空的，那么就通过resize方法来创建一个新的数组。在这里resize方法先不说明，在下一小节扩容的时候会提到。</p>
<p>（3）第二部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">      tab[i] = newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure>

<p>i表示在数组中插入的位置，计算的方式为(n - 1) &amp; hash。在这里需要判断插入的位置是否是冲突的，如果不冲突就直接newNode，插入到数组中即可，这就和流程图中第一个判断框对应了。</p>
<p>如果插入的hash值冲突了，那就转到第三部分，处理冲突</p>
<p>（4）第三部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    //第三部分a</span><br><span class="line">    if (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">        e = p;</span><br><span class="line">    //第三部分b</span><br><span class="line">    else if (p instanceof TreeNode)</span><br><span class="line">        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">    //第三部分c</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">            //第三小节第一段</span><br><span class="line">            if ((e = p.next) == null) &#123;</span><br><span class="line">                p.next = newNode(hash, key, value, null);</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //第三小节第一段</span><br><span class="line">            if (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                break;</span><br><span class="line">            //第三小节第三段</span><br><span class="line">            p = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //第三部分d</span><br><span class="line">    if (e != null) &#123; // existing mapping for key</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">            e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会看到，处理冲突还真是麻烦，好在我们对这一部分又进行了划分</p>
<p>a）第三部分第一小节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (p.hash == hash </span><br><span class="line">     &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">     e = p;</span><br></pre></td></tr></table></figure>

<p>在这里判断table[i]中的元素是否与插入的key一样，若相同那就直接使用插入的值p替换掉旧的值e。</p>
<p>b）第三部分第二小节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else if (p instanceof TreeNode)</span><br><span class="line">       e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br></pre></td></tr></table></figure>

<p>判断插入的数据结构是红黑树还是链表，在这里表示如果是红黑树，那就直接putTreeVal到红黑树中。这就和流程图里面的第二个判断框对应了。</p>
<p>c）第三部分第三小节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第三部分c</span><br><span class="line">else &#123;</span><br><span class="line">     for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">        //第三小节第一段</span><br><span class="line">         if ((e = p.next) == null) &#123;</span><br><span class="line">              p.next = newNode(hash, key, value, null);</span><br><span class="line">              if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                  treeifyBin(tab, hash);</span><br><span class="line">                  break;</span><br><span class="line">         &#125;</span><br><span class="line">         //第三小节第一段</span><br><span class="line">         if (e.hash == hash &amp;&amp;</span><br><span class="line">               ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">              break;</span><br><span class="line">         //第三小节第三段</span><br><span class="line">         p = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数据结构是链表，首先要遍历table数组是否存在，如果不存在直接newNode(hash, key, value, null)。如果存在了直接使用新的value替换掉旧的。</p>
<p>注意一点：不存在并且在链表末尾插入元素的时候，会判断binCount &gt;= TREEIFY_THRESHOLD - 1。也就是判断当前链表的长度是否大于阈值8，如果大于那就会把当前链表转变成红黑树，方法是treeifyBin。这也就和流程图中第三个判断框对应了。</p>
<p>（5）第四部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line">return null;</span><br></pre></td></tr></table></figure>

<p>插入成功之后，还要判断一下实际存在的键值对数量size是否大于阈值threshold。如果大于那就开始扩容了。</p>
<p><strong>3、扩容</strong></p>
<p>为什么扩容呢？很明显就是当前容量不够，也就是put了太多的元素。为此我们还是先给出一个流程图，再来进行分析。</p>
<p><img src="https://pic2.zhimg.com/v2-f43eafe4e5d4d7616f885335fc185f3d_b.jpg" class="lazyload" data-srcset="https://pic2.zhimg.com/v2-f43eafe4e5d4d7616f885335fc185f3d_b.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>这个扩容就比较简单了，HaspMap扩容就是就是先计算 新的hash表容量和新的容量阀值，然后初始化一个新的hash表，将旧的键值对重新映射在新的hash表里。如果在旧的hash表里涉及到红黑树，那么在映射到新的hash表中还涉及到红黑树的拆分。整个流程也符合我们正常扩容一个容量的过程，我们根据流程图结合代码来分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    //第一部分：扩容</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    //第二部分：设置阈值</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    //第三部分：旧数据保存在新数组里面</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                //只有一个节点，通过索引位置直接映射</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                //如果是红黑树，需要进行树拆分然后映射</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123;</span><br><span class="line">                     //如果是多个节点的链表，将原链表拆分为两个链表</span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    //链表1存于原索引</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //链表2存于原索引加上原hash桶长度的偏移量</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这代码量同样让人恶心，不过我们还是分段来分析：</p>
<p>（1）第一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一部分：扩容</span><br><span class="line">if (oldCap &gt; 0) &#123;</span><br><span class="line">      if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">           return oldTab;</span><br><span class="line">      &#125;</span><br><span class="line">      else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">          oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码也能看明白：首先如果超过了数组的最大容量，那么就直接将阈值设置为整数最大值，然后如果没有超过，那就扩容为原来的2倍，这里要注意是oldThr &lt;&lt; 1，移位操作来实现的。</p>
<p>（2）第二部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第二部分：设置阈值</span><br><span class="line">else if (oldThr &gt; 0) //阈值已经初始化了，就直接使用</span><br><span class="line">      newCap = oldThr;</span><br><span class="line">else &#123;    // 没有初始化阈值那就初始化一个默认的容量和阈值</span><br><span class="line">      newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">      newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line">if (newThr == 0) &#123;</span><br><span class="line">      float ft = (float)newCap * loadFactor;</span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">//为当前的容量阈值赋值</span><br><span class="line">threshold = newThr;</span><br><span class="line">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">table = newTab;</span><br></pre></td></tr></table></figure>

<p>首先第一个else if表示如果阈值已经初始化过了，那就直接使用旧的阈值。然后第二个else表示如果没有初始化，那就初始化一个新的数组容量和新的阈值。</p>
<p>（3）第三部分</p>
<p>第三部分同样也很复杂，就是把旧数据复制到新数组里面。这里面需要注意的有下面几种情况：</p>
<p>A：扩容后，若hash值新增参与运算的位=0，那么元素在扩容后的位置=原始位置</p>
<p>B：扩容后，若hash值新增参与运算的位=1，那么元素在扩容后的位置=原始位置+扩容后的旧位置。</p>
<p>hash值新增参与运算的位是什么呢？我们把hash值转变成二进制数字，新增参与运算的位就是倒数第五位。</p>
<p>这里面有一个非常好的设计理念，扩容后长度为原hash表的2倍，于是把hash表分为两半，分为低位和高位，如果能把原链表的键值对， 一半放在低位，一半放在高位，而且是通过e.hash &amp; oldCap == 0来判断，这个判断有什么优点呢？</p>
<p>举个例子：n = 16，二进制为10000，第5位为1，e.hash &amp; oldCap 是否等于0就取决于e.hash第5 位是0还是1，这就相当于有50%的概率放在新hash表低位，50%的概率放在新hash表高位。</p>
<p>OK，到这一步基本上就算是把扩容这一部分讲完了，还有一个问题没有解决，也就是说存储的原理讲明白了，存储的元素多了如何扩容也明白了，扩容之后出现了地址冲突怎么办呢？</p>
<p><strong>4、解决地址冲突</strong></p>
<p>解决地址冲突的前提是计算的hash值出现了重复，我们就先来看看HashMap中，是如何计算hash值的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">     int h;</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码是超级简单，hash值其实就是通过hashcode与16异或计算的来的，为什么要使用异或运算呢？画一张图你就明白了：</p>
<p><img src="https://pic1.zhimg.com/v2-fe6755c8e427026b155c867f11efdbd0_b.jpg" class="lazyload" data-srcset="https://pic1.zhimg.com/v2-fe6755c8e427026b155c867f11efdbd0_b.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>也就是说，通过异或运算能够是的计算出来的hash比较均匀，不容易出现冲突。但是偏偏出现了冲突现象，这时候该如何去解决呢？</p>
<p><strong>在数据结构中，我们处理hash冲突常使用的方法有：开发定址法、再哈希法、链地址法、建立公共溢出区。而hashMap中处理hash冲突的方法就是链地址法。</strong></p>
<p>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<p><img src="https://pic2.zhimg.com/v2-08b1b12dfb7507704d45ecca236ebf91_b.jpg" class="lazyload" data-srcset="https://pic2.zhimg.com/v2-08b1b12dfb7507704d45ecca236ebf91_b.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>相信大家都能看明白，出现地址冲突的时候，一个接一个排成一条链就OK了。正好与HashMap底层的数据结构相呼应。</p>
<p><strong>5、构造一个HashMap</strong></p>
<p>上面可能出现的问题，我们都已经说明了，关于他的构造方法却姗姗来迟。下面我们好好说一下他的构造方法：</p>
<p>他的构造方法一共有四个：</p>
<p>第一个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public HashMap() &#123;</span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">     this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">     if (initialCapacity &lt; 0)</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     this.loadFactor = loadFactor;</span><br><span class="line">     this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这四个构造方法很明显第四个最麻烦，我们就来分析一下第四个构造方法，其他三个自然而然也就明白了。上面出现了两个新的名词：loadFactor和initialCapacity。我们一个一个来分析：</p>
<p>（1）initialCapacity初始容量</p>
<p>官方要求我们要输入一个2的N次幂的值，比如说2、4、8、16等等这些，但是我们忽然一个不小心，输入了一个20怎么办？没关系，虚拟机会根据你输入的值，找一个离20最近的2的N次幂的值，比如说16离他最近，就取16为初始容量。</p>
<p>（2）loadFactor负载因子</p>
<p>负载因子，默认值是0.75。负载因子表示一个散列表的空间的使用程度，有这样一个公式：initailCapacity*loadFactor=HashMap的容量。 所以负载因子越大则散列表的装填程度越高，也就是能容纳更多的元素，元素多了，链表大了，所以此时索引效率就会降低。反之，负载因子越小则链表中的数据量就越稀疏，此时会对空间造成烂费，但是此时索引效率高。</p>
<p>为什么默认值会是0.75呢？我们截取一段jdk文档：</p>
<p><img src="https://pic3.zhimg.com/v2-4e6b224503e39e90b9419946ba2f7166_b.jpg" class="lazyload" data-srcset="https://pic3.zhimg.com/v2-4e6b224503e39e90b9419946ba2f7166_b.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="https://pic1.zhimg.com/v2-2936da1806372ffe26efa072de7da934_b.jpg" class="lazyload" data-srcset="https://pic1.zhimg.com/v2-2936da1806372ffe26efa072de7da934_b.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>英语不好的人看的我真是一脸懵逼，不过好在大概意思还能明白。看第三行Poisson_distribution这不就是泊淞分布嘛。而且最关键的就是</p>
<p>当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p>
<p><strong>6、HashMap为什么是非线程安全的？</strong></p>
<p>想要解决这个问题，答案很简单，因为源码里面方法全部都是非线程安全的呀，你根本找不到synchronized这样的关键字。保证不了线程安全。于是出现了ConcurrentHashMap。</p>
]]></content>
  </entry>
  <entry>
    <title>面试常考问题总结</title>
    <url>/2021/09/25/82c441ab4d2c.html</url>
    <content><![CDATA[<h2 id="计算机网络面试题"><a href="#计算机网络面试题" class="headerlink" title="计算机网络面试题"></a>计算机网络面试题</h2><ol>
<li><p>对TCP协议的了解</p>
</li>
<li><p>TCP的特性以及为什么是可靠的？</p>
</li>
<li><p>三次握手？为什么要做三次握手？</p>
</li>
<li><p>三次握手说一下，ACK为啥加一。</p>
</li>
<li><p>time_wait状态知道不，说一下</p>
</li>
<li><p>HTTP请求报头，状态码</p>
</li>
<li><p>ios模型七层是什么，为什么分层。</p>
</li>
<li><p>   TCP和UDP有什么区别？9</p>
</li>
<li><p>   TCP怎么三次握手的？</p>
</li>
<li><p>   说下TCP断开连接的过程。</p>
</li>
<li><p>   TCP的可靠是怎么保证的</p>
</li>
<li><p>   三次握手、四次挥手、timewait意义</p>
</li>
<li><p>   http状态吗</p>
</li>
<li><p>   http报头有什么</p>
</li>
<li><p>   传输视频用什么协议、传输文件用什么协议</p>
</li>
<li><p>   10亿的数据如何找前10大的</p>
</li>
<li><p>   TCP流量控制怎么实现</p>
</li>
<li><p>   TCP建立链接后，网线突然拔掉，在插上，链接还在不在</p>
</li>
<li><p>   TCP保活定时器应用层能知道吗</p>
</li>
<li><p>   TIME_WAIT会不会占用端口号？TIME_WAIT占用大量端口号，客户端链接不上服务器，怎么解决？</p>
</li>
<li><ol start="20">
<li>   Udp如何实现可靠性传输</li>
</ol>
</li>
<li><ol start="23">
<li>   遥控器控制电视是用tcp还是udp</li>
</ol>
</li>
<li><p>   syn攻击解决方法（回答了一种）</p>
</li>
<li><p>   四次挥手 timewait没有会发生什么（提示下回答）</p>
</li>
<li><p>   epoll 两种模式 边沿触发和水平触发（提示下回答出来）</p>
</li>
<li><p>   虚拟内存 交换区</p>
</li>
<li><p>   set和无序的set谁的效率高为什么</p>
</li>
<li><p>   HTTP的了解  post和get的区别</p>
</li>
<li><p>   HTTP详细的（不会，跳过）</p>
</li>
<li><p>   6.浏览器输入<a href="http://www.maoyan.com发生了什么？">www.maoyan.com发生了什么？</a></p>
</li>
<li><p>   http长链接与短连接？长链接一直不断开会出现什么问题？怎么解决这个问题？</p>
</li>
<li><p>长链接实现原理？</p>
</li>
<li><p>http中GET和POST请求的方式？</p>
</li>
<li><p>http状态码含义，500和502的区别？401？</p>
</li>
<li><p>ARP协议？</p>
</li>
<li><p>http中的一些请求方法。</p>
</li>
<li><p>8、Time_wait 状态的作用</p>
</li>
<li><p>三次握手解决了什么问题</p>
</li>
<li><p>两台主机能同时相互进行三次握手连接嘛</p>
</li>
<li><p>ARP协议 </p>
</li>
<li><p>.为什么有了ip地址还要mac地址</p>
</li>
<li><p>Tcp有可能被劫持吗？  tcp传输过程中信息会泄露吗？</p>
</li>
<li><p>HTTPS怎么保证安全的</p>
</li>
<li><p>查看tcp状态用哪个命令</p>
</li>
<li><p>把这些状态统计起来用哪个命令（比如time_wait状态有几个）</p>
</li>
<li><p>粘包问题</p>
</li>
<li><p>说一下管道，进程间的五种通信方式，三种线程同步方式</p>
</li>
<li><p>为什么用无名管道不用有名管道</p>
</li>
<li><p>除了管道，具体说一下其他方式</p>
</li>
<li><p>.一般网络上的视频传输用的是什么协议</p>
</li>
<li><p>微信支付中客户端发起一笔支付用tcp还是udp</p>
</li>
<li><p>HTTP协议常见的状态码</p>
</li>
<li><p>对称加密和非对称加密的区别</p>
</li>
<li><p>数字签名</p>
</li>
<li><p>tcp拥塞控制知道吗？讲一下拥塞控制</p>
</li>
<li><p>慢启动中的起始值是1，单位是什么？</p>
</li>
<li><p>tcp报文头部有哪些信息，怎么知道自己可以发送多少数据给对方？</p>
</li>
<li><p>socket编程里象征三次握手的地方在哪儿？TCP三次握手四次挥手的状态，如果没有TIME_WAIT状态会怎样，time-wait状态如果很多，怎么避免？</p>
</li>
<li><p>udp发送的数据一定是完整的嘛？</p>
</li>
<li><p>为什么分层？（1）多层之间相互独立，灵活性好（2）结构上可分割开来，易于实现和维护（3）促进标准化工作</p>
</li>
<li><p>问我怎么获取ip地址，我给他讲了从应用层到各层的数据段封装。他说不是，然后让我用电脑打开cmd 输入ipconfig /all 看一下DHCP服务器问我DHCP是干啥的？我说不清楚，然后他给我讲了5分的DHCP原理</p>
</li>
<li><p>问了下进程通讯及目的，进程间内存隔离。</p>
</li>
<li><p>fork3次之后创建几个进程</p>
</li>
<li><p>linux两台主机之间拷贝数据命令</p>
</li>
<li><p>三次握手的过程？每一次都携带什么数据？为什么要给确认报文段中的ack的值加1，为什么不是2,3,4？<br>（1）客户端请求建立连接，发送序列号<br>（2）服务器确认连接，发送确认报文，并发送自己的序列号<br>（3）客户端发送确认报文<br>如果是在建立连接的过程中，那么这仅仅是一个规定，三次握手的协议就是如此说明的。在数据收发的过程中，确认号也表示了在次字节之前的数据已经收到的到确认，可以放心发送后边的数据，加一可以确定下一次发送应该其实的位置。</p>
</li>
<li><p>四次挥手最后主动断开方为什么要等待2MSL？TIME_WAIT状态是什么?<br>（1）保证安全的断开连接，假设被动断开方第一次发送的断开请求报文在网络滞留了，收不到确认又重新发了一次，第二次收到了确认则连接断开，如果此时滞留的报文又到达了，此时主动断开方有可能已经重新建立的tcp连接，就会收到一个错误的报文<br>（2）保证迟到的报文被丢弃</p>
</li>
<li><p>管道是半双工、socket是全双工</p>
</li>
<li><p>TCP和UDP的区别？如何处理TCP粘包问题？<br>Tcp是面向连接的可靠的流式服务<br>Udp是无连接的不可靠的数据报服务<br>粘包问题的解决方法：<br>（1）    暴力解决，每次需要发数据时再建立tcp连接，发送结束就断开连接<br>（2）    定常数据结构，如果规定每次发送的数据报长度是一定的，那么接收方每次读取固定长读的报文即可<br>（3）    不定长数据结构：多数情况我们使用的不是定长的数据结构，第一种方法可以规定一个特殊的符号作为结束符，每当遇到这个结束符才认为该报文接收结束，但是该方法只适用于字符数据，因        为对其他二进制数据无法确定是结束符还是要发送的数据第二种方法是，在固定的偏移位置写入报文的长度，接收方每次读取先获取到报文的长度，再接收该长度大小的报文即可</p>
</li>
<li><p>HTTP协议的报头是什么？请求方法？<br>Http协议的报头是用来区分报文的类型，比如客户端发送一个请求报文，那么该报文是请求报文就要在报头中说明，是响应报文也要在报头中说明。<br>Get、Post</p>
</li>
<li><p>time_wait的意义，2 MLS指的是什么</p>
</li>
<li><p>HTTP协议头部的TTL字段代表什么？代表报文的最大跳数（最长生存时间），主要是为了防止报文段在网络中一直循环的进行传输所设置的，当达到最大跳数后该报文段会被自动丢弃。</p>
</li>
</ol>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol>
<li>进程间通信</li>
<li>线程间通信，</li>
<li>线程间的同步方式具体说</li>
<li>说下共享内存 ，有两个进程，连接同一共享内存，这两个进程映射到共享内存上的虚拟地址是相同的吗？ 两个进程之间通过共享内存共享一段内存地址空间，这个是怎么实现的？</li>
<li>共享内存解决互斥</li>
<li>进程线程的资源分配的区别 </li>
<li>select和epoll吗？有什么区别？</li>
<li>怎样解决线程互斥</li>
<li>虚拟空间地址大小用户态和内核态</li>
<li>系统调用从用户态到内核态的过程</li>
<li>epoll的ET、LT模式 简短的说下</li>
<li>内存泄漏，怎么解决？</li>
<li>用户态内核态，切换过程</li>
<li>如果很多个用户同时用了一个系统调用，会发生什么情况？怎么解决？</li>
<li> Linux2.6版本后内核的抢占式，是依据什么可以进行抢占的</li>
<li>内存对齐，内存对齐是编译器还是操作系统实现的？为什么要有内存对齐？</li>
<li>分页管理和分段管理的区别</li>
<li>软链接和硬链接的区别</li>
<li>udp发送的数据报在网络层丢失了怎么办？应用层会不会知道这个包丢失了？udp知不知道</li>
<li>连续多次malloc和free之后是否能直接使用内存（不懂）</li>
<li>僵尸进程的概念、处理方法？通过信号调用wait函数可能出现的问题？</li>
<li>死锁</li>
<li>协程比线程有哪些优势</li>
<li>.两个进程之间使用管道会启动新进程吗</li>
<li>管道是怎么实现的</li>
<li>多进程和多线程区别？微信底层用的是多进程，你怎么看？（多进程相比多线程的优势），</li>
<li>select,poll,epoll的区别。</li>
<li>代码里面从一个文件读内容，操作系统都做了什么</li>
</ol>
<h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><ol>
<li>文件夹按时间排序显示的命令（没答出来），那ls -t中-t参数是什么意思</li>
<li>查看进程的命令（回答的ps -ef），-ef所表示的意思是什么</li>
<li>用过head命令吗</li>
<li>linux文件合并，进程状态查询，cpu内存使用查询，磁盘内存查询。</li>
<li>如何在Linux下查看磁盘空间？</li>
<li>如何查看端口有没有监听？</li>
<li>查看网络状态的命令</li>
<li>liunx命令，查看进程，查看负载均衡</li>
<li>介绍管道，项目中用的是什么管道，项目中怎么用的管道</li>
<li>Linux中对文件和进程等相关操作的命令。</li>
<li>Linux 查看系统IO的命令</li>
<li>建立软链接的命令</li>
<li>修改文件的读写权限用到的命令，这个命令有哪些参数？</li>
<li>统计文件有多少行、多少字节用什么命令？</li>
<li>查找文件里字符串的命令？</li>
<li>ps的参数</li>
<li>了解脚本，awk sed</li>
<li>如何查看tcp状态，用什么命令？查看进程的命令，查看负载均衡的命令，linux脚本里如何获取文件的某一行某一列数据</li>
<li>如何查看tcp的状态  netstat</li>
<li>如何查看共享内存 ipcs</li>
<li>Tcp查看状态用什么命令，具体的参数，会出现什么状态？TIME_WAIT和CLOSE_WAIT有什么区别？</li>
<li>ttl</li>
<li>缺页中断</li>
<li>strcpy函数原型和实现</li>
<li>内存泄漏了怎么办？有哪些内存泄漏？内存泄漏的检测工具？</li>
<li>布隆过滤器</li>
<li>read和fread的区别，哪个效率高</li>
<li>查看内存运行状态命令（一个八核的系统，如何查看所有内存运行状态）</li>
<li>.Linux下操作指令执行过程</li>
<li>.recv函数返回值的意义</li>
<li>查看共享内存命令</li>
<li>pwd命令怎么实现的</li>
<li>top和ps命令</li>
<li>在linux下，程序出现了死循环，会产生什么现象，除了jdb调试，还有其他什么方法可以查看出现了死循环</li>
<li>linux下buff、swap。。。。。。什么什么的区别</li>
<li>Linux查看资源使用情况，具体是什么函数比较消耗资源。</li>
<li>当你top命令时，每一列的含义是什么讲一下。</li>
<li>已经连接上了，服务器down了，客户端会作何反应。</li>
<li>连接池知道吗？讲一下。</li>
<li>io复用（select和epoll的区别）</li>
<li>要求回答关于进程操作等命令</li>
<li>如果某一进程造成CPU满了，是什么原因造成的，如何解决？</li>
<li>如何查看系统性能/系统监测的命令</li>
<li>top命令中关于负载的命令是什么，loadavg知道吗</li>
<li>负载在操作系统里跟什么关联，怎么判断一个服务负载很高（不会，他解释说跟物理核数有关，任务比核数多会导致CPU频繁切换，负载高，比核数少会让CPU闲置）</li>
<li>随便说，说明操作系统是怎么应用的，当你进行一个操作时，操作系统在这个过程中都做了什么事情，操作系统怎么运转的（我说的是系统调用这个点）</li>
<li>怎么设计一个分布式存储系统</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol>
<li>数据库引擎知道哪些，有什么区别</li>
<li>什么是索引，索引的存储结构是什么</li>
<li>给你一个sql语句,怎么优化</li>
<li>mysql索引方式</li>
<li>数据库提高查询效率的方法？索引的实现原理？</li>
<li>操作系统内存管理？</li>
<li>说一下第二范式和第三范式</li>
<li>索引的底层实现，为什么要用索引？加了索引，还是查询很慢，问题出在哪里？</li>
<li>索引是可以优化查询，那还有其他优化方式吗</li>
<li>索引单列索引和多列索引有什么区别</li>
<li>有哪些Sql优化</li>
<li>聚集索引高效，为什么要有非聚集索引</li>
<li>为什么要建立索引，好处和坏处。</li>
<li>左连接、右连接、内连接讲一下。</li>
<li>？mysql可不可以对多个字段建索引？</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol>
<li>如何解决哈希表的冲突？</li>
<li>B+和B-的区别是什么？b树和b+树有什么却别，分别适合应用在什么场景</li>
<li>map的底层，红黑树的特点，为什么用红黑树而不用别的树</li>
<li>了解nat吗？</li>
<li>map中的key可不可以是结构体？是结构体的话怎么判断key重复</li>
<li>二叉树，平衡树  二叉树：红黑树，平衡二叉树（问的比较细，时间复杂度，特征）</li>
<li>堆栈的区别</li>
<li>堆栈的数据结构</li>
<li>一个email表，有id/name两列，用sql语句删除重复的name，只剩下一个（这个真的触及到盲区了，面试官说可以用join做）</li>
</ol>
<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><ol>
<li>如果有一个项目跑了两天之后崩溃了，怎么查这个原因？    </li>
<li>在Linux下有调试过吗？如果CPU达到100%，怎么调试？如果只有一个程序？如何确认是因为多个线程为响应造成的CPU达满？</li>
<li>除了多线程和多进程之外，什么也可以用来实现并发，提高效率？</li>
<li>对分布式系统的了解，多个地方的服务器怎么保证数据的一致性？</li>
<li>遍历一个文件获取文件后十行（我说用tail命令，他让我不要用命令自己想办法实现，又说了好几种方法他都不满意，最后提示我用快慢指针解决）</li>
<li>设计题：设计一个类似于朋友圈或者微博的软件，上线之后看关注的好友的发的最新动态</li>
<li>情景题：有64皮马，一个马场里有8个跑道，用最少的场数确定跑的最快的4皮马，</li>
<li>买火车票经常出现无法访问，服务器负载过大，如何解决?  客户端方向和服务器方向思考 如何降低服务器上的连接数量。</li>
<li>了解过cache方面的编程么?</li>
<li>TCP和UDP的使用场景。</li>
<li>服务端要给别人回包，但是对端套接字已经关了，服务器会出现什么情况 ?如果只是客户端的进程退出了，会怎么样，从网络交互方面回答</li>
<li>3、有一栋100层高的大楼，给你两个完全相同的玻璃球。假设从某一层开始，丢下玻璃球会摔碎，请问到哪一层会摔碎？（说思想，说了一种方法让继续改进），如果照你说的，先扔x层的思想，怎么确定这个分组。</li>
<li>linux命令中的mv，cp，mv,cp谁的效率快？为什么他们有什么区别？结合指针谈谈他们的实现？如果让你写一个mv,和cp，你会怎么设计？（有什么更好的办法？）。</li>
<li>缓存知道不？作用是什么？在数据库之间加缓存，缓存属于内存吗？数据库的数据在哪儿放着？</li>
<li>10.编程题找10亿个数字前100大</li>
<li>udp报文最大发送大小     </li>
<li>读文件找出积分最高的100个用户 大顶堆 treemap （其实我的思路是优先队列，但面试官要我用treemap）</li>
</ol>
<h2 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h2><ol>
<li>找到一个链表环的入口</li>
<li>二进制转换成8进制</li>
<li>大文件去重排序</li>
<li>，冒泡、归并、快排、选择排序的时间复杂度？</li>
<li>atoi</li>
<li>快排怎么实现的，讲思路</li>
<li>怎么用两个栈实现一个队列？有没有更好的办法</li>
<li>编写代码，求二叉树的宽度</li>
<li>将100,101,102,103,104,105以数组的形式写入到Dest.txt文件中，并以相反的顺序读出显示在屏幕上。</li>
<li><ol start="5">
<li>   给出10G的数据，每条存储的一条ip地址，求重复率最高的top5</li>
</ol>
</li>
<li>有s个人，围着桌子坐，随机选取一个人开始报数，报到m号时将他剔除，重新开始报数，依次进行，输出剔除序列（主要说数据结构）</li>
<li>对数据进行排序，选择算法进行排序（我选了快排加插入）？排序思想</li>
<li>海量数据进行排序</li>
<li>排序有没有考虑堆排？我说堆排适用于topk之类的算法</li>
<li>1~10000个数随机取出一个数，且乱序，找出这个数</li>
<li>链表找环</li>
<li>大根堆，小根堆。</li>
<li>一个单向链表，应该怎么样设计一个方法，看里面是否存在一个环 除了快慢指针还有什么办法   要求空间复杂度是O(1)</li>
<li>寻找数组中前10大的数据？时间复杂度？排序：如果数字基于有序：插入排序、希尔排序 如果数字毫无规则：快速排序  如果数字集中在某个较小的区域内，建立哈希表</li>
<li>升序数组找出和为指定数字的所有对(小米)</li>
<li>1 3 5 6 4 1类似这种先升后降的单链表 将其变成排好序的链表（小米）</li>
<li>一个数组中一个数出现两次，其它数都出现四次，要求找出这个数，要求时间复杂度nlogn，空间复杂度logn，</li>
</ol>
<ol start="20">
<li>进程间通讯的方式有哪些？使用同一块共享内存的进程使用的虚拟地址相同吗？为什么？<br>信号、信号量、共享内存、消息队列、管道、套接字<br>有可能相同有可能不同，共享内存实际上已相当于文件，对于共享内存的文件映射到内存，如果两个进程完全相同的话，虚拟地址就是相同的，比如fork出来的进程和父进程访问同一个共享内存虚拟地址就可能相同。而进程如果有一点细微的不同，那么虚拟地址就会有差异</li>
</ol>
<h2 id="语言方面："><a href="#语言方面：" class="headerlink" title="语言方面："></a>语言方面：</h2><ol>
<li>i++是原子操作</li>
<li>多态</li>
<li>new一个对象，new之后java后台做了哪些工作</li>
<li>类加载过程</li>
<li>双亲委派模型的好处</li>
<li>怎样破坏双亲委派模型</li>
<li>互斥锁 读写锁 读写锁怎么用 手写实现一个读写锁（。。。不会）</li>
<li>用多线程手写一个生产者消费者模型（。。。也不会）</li>
<li>事务 并发事务造成的问题 事务的隔离级别</li>
<li>索引 聚集 非聚集 B+树 唯一性索引 普通索引 全文索引 最左前缀 联合索引</li>
<li>锁 表锁中共享读锁 独占写锁 行锁中共享锁 排他锁</li>
<li>乐观锁 悲观锁 间隙锁 （当时忘讲意向锁了）</li>
<li>项目中用到的索引有啥？</li>
<li>实际应用中有用到锁机制吗？</li>
<li>多线程锁的区别</li>
<li>Java访问修饰符的区别</li>
<li>为什么重写equals方法必须重写hashcode()方法。</li>
<li>如何实现子线程结束父线程才能结束</li>
<li>Spring AOP的原理</li>
</ol>
<p>c++；</p>
<ol>
<li>说下基类派生类的构造析构顺序？</li>
<li>构造函数能不能是纯虚函数？ 不能的原因？</li>
</ol>
<p>设计模式</p>
<ol>
<li>观察者模式是什么？大致说一下代码</li>
<li>单例模式 手写单例模式（写的双重if判断带锁的）-》问怎么优化？饿汉模式、懒汉模式 以及具体使用场景 使用单例模式应该注意什么<br>为什么要使用单例模式<br>（3）工厂模式 普通工厂 抽象工厂<br>（4）观察者模式</li>
</ol>
<h2 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h2><ol>
<li>多级缓存是怎么做的，怎么保证缓存中的数据是最新的</li>
<li>分布式下，怎么保证多个定时任务服务不会重复执行？</li>
<li>一个用户订单表，一个用户有可能多个订单，查询出每个用户的最新订单（当时脑子抽筋了，想太复杂了，后面想了一下好像只要先group by 再 max（date））</li>
<li>Java 新建线程有哪几种方式</li>
<li>Java 内存区域，new出来的对象分配在哪里，堆内存里面是怎么划分的，为什么要分为新生代，老年代</li>
<li>线程有哪些状态，阻塞状态和等待状态有什么区别</li>
<li>数据库建立索引的原则，复合索引的命中规则</li>
<li>zookeeper 节点类型</li>
<li>说下 spring 的 IOC 与 AOP</li>
<li>Java 反射有哪几种方式</li>
<li>-1000 到 1000 这两千个数用什么排序比较好</li>
<li>100 万个数用什么排序比较好</li>
<li>解决哈希冲突的方法</li>
<li>HashMap 的源码，把知道的都说说，后面追问 HashMap 扩容后怎么确定的元素在新的数组中的位置</li>
<li>B 树与 B+ 树的区别</li>
<li>redis 为什么快</li>
<li>怎么解决缓存穿透和缓存击穿，例如有黑客一直请求 id=-1 的数据怎么办？</li>
<li>Java的集合有了解吗，有哪几种</li>
<li>了解HashMap吗</li>
<li>HashMap的原理讲一下</li>
<li>HashMap和HashTable有什么区别</li>
<li>HashTable和ConCurrentHashMap的区别</li>
<li>HashMap的get实现是怎样的一个过程</li>
<li>多线程了解吗，讲一下线程的操作</li>
<li>sleep和wait的区别</li>
<li>线程池有了解吗</li>
<li>有哪几种线程池</li>
<li>线程池的优点</li>
<li>java的泛型了解吗，一般用在什么场景        泛型就是把类型参数化，在编译的时候才会确定具体的参数。可以用在类、接口、方法中。场景：我觉得当类 方法 接口 这些 当我们不确定使用的对象的类型是啥 或者 可能存在多种类型的可能的时候，可以使用泛型。最熟悉的就是集合类的实现都用到了泛型，这样我们在用的时候可以在&lt;&gt;中指定自己的需求，而不针对每种类型设计一个新的类。用上泛型可以提高类型的安全性，避免强转等。（有官方回答的求指导）</li>
<li>什么场景用String，什么场景用StringBuffer 看需求 是否存在线程安全问题，空间限制，时间限制</li>
<li>JVM怎么判断对象是否可以回收（可达性分析法）</li>
<li>可达性分析法中一般可以选哪些对象作为GC root，常量可以吗？虚拟机栈(栈帧中的本地变量表)中引用的对象。方法区中静态属性引用的对象。方法区中常量引用的对象。本地方法栈中(Native方法)引用的对象</li>
<li>springBoot启动流程</li>
<li>springMVC请求流程(不会，答适配器模式，json互相转换，就硬扯)</li>
<li>springboot自动配置原理(好多次问到我这个了，我是真的不会呀，八股文一背就会，一说就废)</li>
<li>定义了事务但是事务失效的场景</li>
<li>拦截器原理(不会)</li>
<li>mybatis动态SQL原理(不会)</li>
<li>已经在zookeeper中注册了的类，再次注册会怎样(知识盲区，不会)</li>
<li>Redis的5种数据类型以及底层数据结构</li>
<li>ArrayList和LinkedList的区别和应用场景</li>
<li>上面的两个集合对应的线程安全类</li>
<li>LinkedBlockQueue源码</li>
<li>CopyOnWriteArrayList源码</li>
<li>HashMap源码</li>
<li>ConcurrentHashMap源码</li>
<li>问多线程了解吗(因为框架答得不好，就说了精通多线程，哈哈哈，头铁)</li>
<li>线程创建方式</li>
<li>FutureTask如何获取返回值</li>
<li>Java线程生命周期和操作系统生命周期</li>
<li>多线程的debug</li>
<li>如何解决并发问题</li>
<li>AQS源码</li>
<li>公平锁，非公平锁，可重入锁，不可重入锁怎么设计的</li>
<li>CountDownLatch源码</li>
<li>四种引用类型以及应用场景</li>
<li>threadlocal源码</li>
<li>synchronized修饰静态方法和非静态方法区别</li>
<li>字节码中两个monitorexit分别代表什么</li>
<li>读写屏障</li>
<li>synchronized可重入原理</li>
<li>从OS层面讲一下为什么synchronized要尽量减小加锁范围和避免重入</li>
<li>synchronized锁升级过程</li>
<li>如何判断对象锁状态</li>
<li>偏心锁的记录过程</li>
<li>什么情况下hash码处不能放线程ID</li>
<li>hashcode如何计算</li>
<li>对象如何分配，垃圾如何回收，经历了哪些流程</li>
<li>很多线程同时往Eden区同时申请内存，分配对象，虚拟机怎么减少往同一块内存上分配对象的冲突</li>
<li>gc分代年龄最大值，为什么最大值是15</li>
<li>假设你设计jvm，你会在哪存gc年龄</li>
<li>cms是老年代垃圾回收器，它的搭档有哪些?</li>
<li>cms为什么使用串行垃圾回收器作为备案</li>
<li>cms如何调优</li>
<li>G1垃圾回收过程</li>
<li>散射标记法(完全没听过)</li>
<li>颜色指针</li>
<li>B+树数据结构，聚簇索引，回表</li>
<li>没有唯一值，还有聚簇索引吗</li>
<li>explain会关注哪些信息</li>
<li>索引失效场景</li>
<li>jmm</li>
<li>volatile</li>
<li>指令重排序，内存屏障</li>
<li>cas/aba问题</li>
<li>synchronized锁升级过程</li>
<li>自旋锁一定会提高效率？</li>
<li>重量级锁的原理</li>
<li>线程池七大参数&amp;拒绝策略&amp;工作原理</li>
<li>JUC相关知道哪些？</li>
<li>集合ArrayList，hashmap，linkedlist，concurrentHashmap原理&amp;扩容机制</li>
<li>知道哪些Gc算法，可达性分析算法什么对象做为根对象？</li>
<li>Tcp知道什么（说了保证可靠性的机制&amp;提高性能的机制）</li>
<li>幂等性的实现</li>
<li>线程池中的线程为什么可以一直处理任务不销毁</li>
<li>mvc 和 servlet 的关系</li>
<li>ping 在什么层</li>
<li>创建一个存放100个元素的 hashmap 应该设置多大保证不扩容</li>
<li>linux进程之间怎么通信的。(IPC)</li>
<li>多态问的很底层 两个方法，一个参数string，一个参数obj， 调用传参null，问调用哪个方法， 不会</li>
<li>10亿个数找两个重复数字 </li>
<li>10亿个数找最小10个</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>review</tag>
      </tags>
  </entry>
</search>
